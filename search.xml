<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[弄懂Fail-Safe,Fail-First]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%BC%84%E6%87%82Fail-Safe-Fail-First%2F</url>
    <content type="text"><![CDATA[今天在做算法题的时候，碰到的如下问题，记录下来加深记忆。很多时候我们都有这样一个需求，在迭代的时候（满足某个给定的条件）添加或者删除元素。结果却是等来了java.util.ConcurrentModificationException这个异常，追踪其原因，就是有些容器是Fail-Safe，Fail-First的 今天在做算法题的时候，碰到的如下问题，记录下来加深记忆。很多时候我们都有这样一个需求，在迭代的时候（满足某个给定的条件）添加或者删除元素。结果却是等来了java.util.ConcurrentModificationException这个异常，追踪其原因，就是有些容器是Fail-Safe，Fail-First的。出现异常的代码如下：12345678910111213public class CollectionTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (int a : arrayList) &#123; if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125;&#125; 1. Fail-Safe,Fail-First概念。 在ArrayList的里面有个内部类Itr。当我们获取到迭代器的时候，就会对这个类进行初始化，来看下这个类的源码，分析初始化做了些什么。123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 在初始化的时候，它会让expectedModCount = modCount，modCount在AbstractList，每次对ArrayList的结构性改变（remove,add）都会使得modCount相应的减1或者加1。来分析下我们刚开始出现问题的代码。当我们获取到迭代器的时候，此时expectedModCount = modCount。当remove的时候，modCount会加1，但是expectedModCount却不变，当执行Itr的next()操作时候，会执行上述源码中的checkForComodification()来检查expectedModCount = modCount，若不相等，则会throw ConcurrentModificationException。所以就不难分析出上述问题。 FailFirst:当我们在迭代获取集合元素的时候，在迭代器创建之后，对集合做一些结构性的改变（remove,add操作)，那么FailFirst容器首先会抛出 ConcurrentModificationException。 2. 如何解决上述问题。12345678910111213public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); ArrayList sub=new ArrayList(); for(int a:arrayList)&#123; if(a==1) sub.add(a); &#125; arrayList.removeAll(sub); System.out.println(arrayList); &#125; 上述这个办法好，但是却占额外空间。1234567891011121314public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) iterator.remove(); &#125; System.out.println(arrayList); &#125; 这样就不占额外的空间，是更好的办法。 iterator.remove()为啥不会抛异常，看看源码1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; expectedModCount = modCount;这句起作用，它删除元素后它会强制满足条件。所以不会抛异常。 3. Fail-First的出场 。 将刚开始的代码换成如下的形式,问题迎刃而解。1234567891011121314public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;Integer&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125; 像CopyOnWriteArrayList这类容器就属于Fail-Safe容器。当集合结构改变的时候不会抛出异常，这是因为他们只是原始集合的复制，它用snapshot这个数组来保存集合。所以你原始集合的修改只会让原来的引用指向新的数组，而旧的引用还是被迭代器的snapshot所引用。因而他们属于Fail-Safe容器。看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; private boolean remove(Object o, Object[] snapshot, int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 从上面可以看出每次添加元素都是线程安全的，因为加了锁。另外，每添加一个元素，都会把原来的引用指向一个新的数组。所以对他进行操作没问题。所以使用Fail-Safe容器也是一种很好的解决办法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式2---观察者模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在我们的开发工作中，经常会遇到这样的问题。例如：对于A，对象B，C在原来引用了A。现在对象A的属性发生了变化，我们的需求是B，C能够同时感应到这种变化。且新增的对象D，也要引用A对象，那如何在不改变原来代码的基础上，如何做到呢。此时，观察者模式就能够很好的解决这个问题。 1. 为何需要观察者模式（why) 在我们的开发工作中，经常会遇到这样的问题。例如：对于A，对象B，C在原来引用了A。现在对象A的属性发生了变化，我们的需求是B，C能够同时感应到这种变化。且新增的对象D，也要引用A对象，那如何在不改变原来代码的基础上，如何做到呢。此时，观察者模式就能够很好的解决这个问题。 Defidition:观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 下面通过一个和实例逐步弄清楚什么是观察者模式。 2. 如何实现观察者模式（通过实例来讲解how） 某气象站有这样一个应用：它实时检测当地温度，适度，压强。并让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都能实时更新相应的数据。气象站提供的数据结构如下。123456public class WeatherData &#123; float temp; float humidity; float pressture;//省略get,set方法&#125; 我们想到的办法就是让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都成为气象站的观察者，他们只需要在气象站注册，当气象站的数据发生变化的时候，会遍历每个观察者，调用update（）实现更新操作。step1:定义抽象接口1234567891011121314151617181920public interface Subject &#123; //主题，即气象站的抽象接口 //注册观察者 public void registerObserver(Observer o); //取消观察者 public void removeObserver(Observer o); //通知观察者执行更新操作 public void notifyObservers();&#125;public interface Observer &#123; //更新操作，等待Subject调用就实现了通知 public void update(float temp,float humidy,float pressure);&#125;public interface DisplayElement &#123; //对更新进行展示 public void display();&#125; 上述是接口，便于代码重用和面向接口编程，而不是面向实现编程。step2:实现具体的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressture; public WeatherData()&#123; observers=new ArrayList(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i=observers.indexOf(o); if(i&gt;=0) observers.remove(i); &#125; @Override public void notifyObservers() &#123; observers.stream().forEach((observer)-&gt;observer.update(temperature,humidity,pressture)); &#125; public void measurementsChanged()&#123;//通知 notifyObservers(); &#125; //属性改变了 public void setMeasurements(float temperature,float humidity,float pressture)&#123; this.temperature=temperature; this.humidity=humidity; this.pressture=pressture; measurementsChanged(); &#125;&#125; step3:Observer这里只提供一种实现，剩下的可以同样生成。123456789101112131415161718192021222324252627282930** * Created by maskwang on 2017/10/5 0005. * 时间原因这里只提供一种实现 */public class CurrentConditionsDisplay implements Observer,DisplayElement &#123; //这个观察者只在乎以下两个属性 private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this);//注册 &#125; @Override public void display() &#123; System.out.println(temperature+"**"+humidity); &#125; @Override public void update(float temp, float humidy, float pressure) &#123; this.humidity=humidy; this.temperature=temp; display(); &#125;&#125; step4:测试类12345678910111213public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); //订阅那个Object CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(80,65,30.2f); weatherData.setMeasurements(82,70,28.4f); weatherData.setMeasurements(83,72,27.5f); &#125;&#125; Uml类图如下： 结果如下： 可以看到每次Subject变化，Observer跟着变化。 3. 观察者模式总结（conclusion） 以上实例可以看出来，观察者模式实现了Obseerver和Subject的解耦，Subject可以增删任意Observer,而Observer可以订阅任意的Subject。很好的满足了这种需求。这让我activemq，它其中就有一种发布订阅模式，在这里面生产者产生的消息，都能理解被消费者立即订阅到。可以看的出来这种思想应用的还是很广的。附上对应的github地址： https://github.com/maskwang520/designpattern.git]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式1-策略模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 1. 为什么需要策略模式 考虑到如下一个场景，你构造一个Duck的SuperClass,以后各种各样的鸭子都继承该SuperClass ,代码实现应该如下。12345678910111213public class Duck &#123; public void quack()&#123; //会叫 System.out.println("I can quack"); &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 具体的实现类如下123456789101112public class GreeHeadDuck extends Duck &#123; //绿头鸭 @Override public void play()&#123; System.out.println("I am green duck"); &#125;&#125;public class RedHeadDuck extends Duck&#123; //红头鸭 @Override public void play()&#123; System.out.println("I am red duck"); &#125;&#125; 上面这样看起来也没毛病啊，但是它有个问题就是，当给SuperClass加上fly()方法后，表示每个子类都会飞。即便是我后来的子类不能飞，它也可以fly。此时，我们可能会想到，覆盖fly()方法，方法里面什么都不做。但是问题还是很突出。原因如下： 代码在多个子类中重复。不管是什么类型的鸭子，都会继承来SuperClass的所有属性和方法，这其中有些子类根本就不具备。 运行时的行为不容易改变。我想让某个鸭子换个叫声，在不动SuperClass的情况下做不到。 很难知道所有鸭子共同的行为。比如fly方法，有些鸭子不具备，但是还是在父类中。 改一发动全身，我上面还是只添加fly(),有些鸭子不会飞，但是要覆盖方法。 我们接着可能会采用如下的解决办法，把fly,display从超类中抽出来，放进一个Flayable接口中。把quack()抽出来，放进Quackable接口中，代码如下。123456public interface Quackable &#123; //会叫的接口 public void quack();&#125;public interface Flyable &#123; //会飞接口 public void fly();&#125; 这样对于多个会飞Duck子类，每个子类都有一个实现Flyable()的类，在里面覆写fly()方法，会造成太多Flyable()的子类，无法复用。其次，还不能动态改变fly行为，因为已经写死啦。此时，设计原则就出来了，即：找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混到一起。 2. 如何使用策略模式 解决上述问题的根本是分开变化和不会变化的部分。Duck类中的fly(),quack()会随着鸭子的不同而改变，那我们将它们从Duck类中取出来，建立一组新类来代表每个行为。此时，设计原则就应用上了即，针对接口编程，而不是针对实现编程 这句话的理解在这里就是针对超类编程。前面我们设计 Quackable，Flyable，然后让具体的类去实现这两个接口，这样，就是针对实现编程，不利于动态修改和以后的拓展。因此，我们编写两个FlyBehavior,QuackBehavior两个接口，以及他们的实现类，这样，我们把FlyBehavior和QuackBehavior作为超类的属性，这个具体的实现通过set方法通过set()传递进去，这样实现面向接口编程，可以动态改变，也可以复用代码。代码实现如下：行为接口123456public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125; 实现类12345678910111213141516171819202122232425public class FlyNoWay implements FlyBehavior &#123; //不能飞 @Override public void fly() &#123; System.out.println("I can FlyNoWay"); &#125;&#125;public class FlyWithWins implements FlyBehavior &#123; //用翅膀飞 @Override public void fly() &#123; System.out.println("i can fly with wins"); &#125;&#125;public class Quack implements QuackBehavior &#123; //一般的叫 @Override public void quack() &#123; System.out.println("quack"); &#125;&#125;public class Squack implements QuackBehavior &#123; //嘶叫 @Override public void quack() &#123; System.out.println("squack"); &#125;&#125; 把基本接口作为超类的属性成员，面向接口编程12345678910111213141516171819202122232425262728public class Duck &#123; private FlyBehavior flyBehavior; //代理类，组合模式 private QuackBehavior quackBehavior; public void fly()&#123; flyBehavior.fly(); &#125; public void quack()&#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 测试类如下123456789public class Main &#123; public static void main(String[] args) &#123; Duck duck=new Duck(); duck.setFlyBehavior(new FlyNoWay()); duck.fly(); duck.setFlyBehavior(new FlyWithWins()); duck.fly(); &#125;&#125; 结果如下图 总结：上述做法的好处，面对不同飞行类型，可以在不修改Duck的基础上实现，这就是策略模式，根据你传入进来的具体实现类，执行不同的行为，这里关键就是运用多态这一特点。其次，不同的实现类可以复用，以前针对每个子类都有实现类，现在同一类型的都可以采用同一个实现类。 3. 结论 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，简单来说，就是定义了基础接口封装在类属性里面，可以根据不同的实现类，动态的改变行为。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>