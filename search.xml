<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Springboot用WebSocket构建交互式的web应用]]></title>
    <url>%2F2017%2F10%2F12%2FSpringboot%E7%94%A8WebSocket%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebSocket是html5带来的一项重大的特性，使得浏览器与服务端之间真正长连接交互成为了可能，这篇文章会带领大家窥探一下Spring 对WebSocket的支持及使用。 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭HTTP协议的长连接和短连接，这两种实质上是TCP协议的长连接和短连接。 项目结构 12345678910111213└── src └── main └── java └── hello └── config └── WebsocketConfig.java └── controller └── GreetingController.java └── message └── Greeting.java └── HelloMessage.java └──test └── pom.xml 1.Maven引入Jar包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;sprigboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.编写客户端发送的消息和服务端回复的消息Java类1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class HelloMessage &#123; String name; public HelloMessage() &#123; &#125; public HelloMessage(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class Greeting &#123; String content; public Greeting() &#123; &#125; public Greeting(String content) &#123; this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 注意在上面要有默认的构造器，没有的话，则会出现下面问题 这是因为序列化后，如果没有默认的构造器，则会让Springboot的默认序列化Jackson不能构造成原来的对象，反序列化还是需要通过默认的构造器来实现的 。客户端发送HelloMessage,服务端服务以Greeting。 ####3.Websocket配置类12345678910111213141516171819202122232425262728package hello.config;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;/** * Created by maskwang on 2017/10/12 0012. */@Configuration@EnableWebSocketMessageBrokerpublic class WebsocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123; @Override public void configureMessageBroker(MessageBrokerRegistry config) &#123; //客户端接收服务端消息的地址的前缀信息（客户端接受） config.enableSimpleBroker("/topic"); //客户端给服务端发消息的地址的前缀（客户端发送） config.setApplicationDestinationPrefixes("/app"); &#125; //这个方法的作用是添加一个服务端点，来接收客户端的连接。并开启SockJS的支持。 @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint("/socket").withSockJS(); &#125;&#125; registry.addEndpoint(“/socket”)表示添加了一个/socket端点，客户端和服务端就可以通过这个端点来进行连接。 withSockJS()的作用是开启SockJS支持 @EnableWebSocketMessageBroker别忘了。 configureMessageBroker(MessageBrokerRegistry config)定义消息代理，也就是服务端和客户端他们之间交换消息的规范。config.enableSimpleBroker(“/topic”);表明客户端接受服务端的消息时候，服务端的请求地址前缀。config.setApplicationDestinationPrefixes(“/app”)表明服务端接受客户端时候，客户端的请求地址前缀。4. 编写业务代码12345678910111213141516171819202122package hello.controller;import hello.messaage.Greeting;import hello.messaage.HelloMessage;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.stereotype.Controller;/** * Created by maskwang on 2017/10/12 0012. */@Controllerpublic class GreetingController &#123; @MessageMapping("/hello") //转发给服务端 @SendTo("/topic/greetings") public Greeting greeting(HelloMessage message) throws Exception &#123; Thread.sleep(1000); // simulated delay return new Greeting("Hello, " + message.getName() + "!"); &#125;&#125; @SendTo(“/topic/greetings”)是客户端发起连接后，订阅服务端消息时指定的一个地址，用于接收服务端的返回，也就是服务端返回的消息在客户端在订阅这个地址的消息后，客户端可以收到。定义怎样的客户端。 @MessageMapping(“/hello”)定义这个地址客户端发送的消息就会被映射这样的服务端。也就是客户端寻找那个服务端。定义了什么样的服务端。 理解上面两点很重要，后面都与这有关。 5. 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello WebSocket&lt;/title&gt; &lt;link href="/webjars/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link href="/main.css" rel="stylesheet"&gt; &lt;script src="/webjars/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/sockjs-client/1.0.2/sockjs.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/stomp-websocket/2.3.3/stomp.min.js"&gt;&lt;/script&gt; &lt;script src="/app.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;h2 style="color: #ff0000"&gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;&lt;div id="main-content" class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="connect"&gt;WebSocket connection:&lt;/label&gt; &lt;button id="connect" class="btn btn-default" type="submit"&gt;Connect&lt;/button&gt; &lt;button id="disconnect" class="btn btn-default" type="submit" disabled="disabled"&gt;Disconnect &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;What is your name?&lt;/label&gt; &lt;input type="text" id="name" class="form-control" placeholder="Your name here..."&gt; &lt;/div&gt; &lt;button id="send" class="btn btn-default" type="submit"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;table id="conversation" class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Greetings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="greetings"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var stompClient = null;function setConnected(connected) &#123; $("#connect").prop("disabled", connected); $("#disconnect").prop("disabled", !connected); if (connected) &#123; $("#conversation").show(); &#125; else &#123; $("#conversation").hide(); &#125; $("#greetings").html("");&#125;function connect() &#123; var socket = new SockJS('/socket'); //链接socket stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content); &#125;); &#125;);&#125;function disconnect() &#123; if (stompClient !== null) &#123; stompClient.disconnect(); &#125; setConnected(false); console.log("Disconnected");&#125;function sendName() &#123; stompClient.send("/app/hello", &#123;&#125;, JSON.stringify(&#123;'name': $("#name").val()&#125;));&#125;function showGreeting(message) &#123; $("#greetings").append("&lt;tr&gt;&lt;td&gt;" + message + "&lt;/td&gt;&lt;/tr&gt;");&#125;$(function () &#123; $("form").on('submit', function (e) &#123; e.preventDefault(); &#125;); $( "#connect" ).click(function() &#123; connect(); &#125;); $( "#disconnect" ).click(function() &#123; disconnect(); &#125;); $( "#send" ).click(function() &#123; sendName(); &#125;);&#125;); 前端我们需要用到两个js文件：sockjs.js和stomp.js SockJS：SockJS 是一个浏览器上运行的 JavaScript 库，如果浏览器不支持 WebSocket，该库可以模拟对 WebSocket 的支持，实现浏览器和 Web 服务器之间低延迟、全双工、跨域的通讯通道。StompStomp 提供了客户端和代理之间进行广泛消息传输的框架。Stomp 是一个非常简单而且易用的通讯协议实现，尽管代理端的编写可能非常复杂，但是编写一个 Stomp 客户端却是很简单的事情，另外你可以使用 Telnet 来与你的 Stomp 代理进行交互。 开启Socket var socket = new SockJS(‘/socket’); 先构建一个SockJS对象 stompClient = Stomp.over(socket); 用Stomp将SockJS进行协议封装 stompClient.connect()与服务端进行连接，同时有一个回调函数，处理连接成功后的操作信息。发送消息 stompClient.send(“/app/hello”, {}, JSON.stringify({‘name’: $(“#name”).val()}));是客户端向服务端发送消息 stompClient.subscribe(‘/topic/greetings’, function (greeting) { showGreeting(JSON.parse(greeting.body).content); }); //是服务端向客户端发送消息 点击connect后，发动任何message,服务端都会延迟一秒后，回复hello,message! 参考文献 HTTP长连接和短连接 Spring官方websocket例子 Spring WebSocket初探1 (Spring WebSocket入门教程)]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弄懂Fail-Safe,Fail-First]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%BC%84%E6%87%82Fail-Safe-Fail-First%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天在做算法题的时候，碰到的如下问题，记录下来加深记忆。很多时候我们都有这样一个需求，在迭代的时候（满足某个给定的条件）添加或者删除元素。结果却是等来了java.util.ConcurrentModificationException这个异常，追踪其原因，就是有些容器是Fail-Safe，Fail-First的12345678910111213public class CollectionTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (int a : arrayList) &#123; if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125;&#125; 1. Fail-Safe,Fail-First概念。 在ArrayList的里面有个内部类Itr。当我们获取到迭代器的时候，就会对这个类进行初始化，来看下这个类的源码，分析初始化做了些什么。123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 在初始化的时候，它会让expectedModCount = modCount，modCount在AbstractList，每次对ArrayList的结构性改变（remove,add）都会使得modCount相应的减1或者加1。来分析下我们刚开始出现问题的代码。当我们获取到迭代器的时候，此时expectedModCount = modCount。当remove的时候，modCount会加1，但是expectedModCount却不变，当执行Itr的next()操作时候，会执行上述源码中的checkForComodification()来检查expectedModCount = modCount，若不相等，则会throw ConcurrentModificationException。所以就不难分析出上述问题。 FailFirst:当我们在迭代获取集合元素的时候，在迭代器创建之后，对集合做一些结构性的改变（remove,add操作)，那么FailFirst容器首先会抛出 ConcurrentModificationException。 2. 如何解决上述问题。12345678910111213public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); ArrayList sub=new ArrayList(); for(int a:arrayList)&#123; if(a==1) sub.add(a); &#125; arrayList.removeAll(sub); System.out.println(arrayList); &#125; 上述这个办法好，但是却占额外空间。1234567891011121314public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) iterator.remove(); &#125; System.out.println(arrayList); &#125; 这样就不占额外的空间，是更好的办法。 iterator.remove()为啥不会抛异常，看看源码1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; expectedModCount = modCount;这句起作用，它删除元素后它会强制满足条件。所以不会抛异常。 3. Fail-First的出场 。 将刚开始的代码换成如下的形式,问题迎刃而解。1234567891011121314public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;Integer&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125; 像CopyOnWriteArrayList这类容器就属于Fail-Safe容器。当集合结构改变的时候不会抛出异常，这是因为他们只是原始集合的复制，它用snapshot这个数组来保存集合。所以你原始集合的修改只会让原来的引用指向新的数组，而旧的引用还是被迭代器的snapshot所引用。因而他们属于Fail-Safe容器。看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; private boolean remove(Object o, Object[] snapshot, int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 从上面可以看出每次添加元素都是线程安全的，因为加了锁。另外，每添加一个元素，都会把原来的引用指向一个新的数组。所以对他进行操作没问题。所以使用Fail-Safe容器也是一种很好的解决办法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式2---观察者模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的开发工作中，经常会遇到这样的问题。例如：对于A，对象B，C在原来引用了A。现在对象A的属性发生了变化，我们的需求是B，C能够同时感应到这种变化。且新增的对象D，也要引用A对象，那如何在不改变原来代码的基础上，如何做到呢。此时，观察者模式就能够很好的解决这个问题。 1. 为何需要观察者模式（why) Defidition:观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 下面通过一个和实例逐步弄清楚什么是观察者模式。 2. 如何实现观察者模式（通过实例来讲解how） 某气象站有这样一个应用：它实时检测当地温度，适度，压强。并让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都能实时更新相应的数据。气象站提供的数据结构如下。123456public class WeatherData &#123; float temp; float humidity; float pressture;//省略get,set方法&#125; 我们想到的办法就是让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都成为气象站的观察者，他们只需要在气象站注册，当气象站的数据发生变化的时候，会遍历每个观察者，调用update（）实现更新操作。step1:定义抽象接口1234567891011121314151617181920public interface Subject &#123; //主题，即气象站的抽象接口 //注册观察者 public void registerObserver(Observer o); //取消观察者 public void removeObserver(Observer o); //通知观察者执行更新操作 public void notifyObservers();&#125;public interface Observer &#123; //更新操作，等待Subject调用就实现了通知 public void update(float temp,float humidy,float pressure);&#125;public interface DisplayElement &#123; //对更新进行展示 public void display();&#125; 上述是接口，便于代码重用和面向接口编程，而不是面向实现编程。step2:实现具体的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressture; public WeatherData()&#123; observers=new ArrayList(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i=observers.indexOf(o); if(i&gt;=0) observers.remove(i); &#125; @Override public void notifyObservers() &#123; observers.stream().forEach((observer)-&gt;observer.update(temperature,humidity,pressture)); &#125; public void measurementsChanged()&#123;//通知 notifyObservers(); &#125; //属性改变了 public void setMeasurements(float temperature,float humidity,float pressture)&#123; this.temperature=temperature; this.humidity=humidity; this.pressture=pressture; measurementsChanged(); &#125;&#125; step3:Observer这里只提供一种实现，剩下的可以同样生成。123456789101112131415161718192021222324252627282930** * Created by maskwang on 2017/10/5 0005. * 时间原因这里只提供一种实现 */public class CurrentConditionsDisplay implements Observer,DisplayElement &#123; //这个观察者只在乎以下两个属性 private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this);//注册 &#125; @Override public void display() &#123; System.out.println(temperature+"**"+humidity); &#125; @Override public void update(float temp, float humidy, float pressure) &#123; this.humidity=humidy; this.temperature=temp; display(); &#125;&#125; step4:测试类12345678910111213public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); //订阅那个Object CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(80,65,30.2f); weatherData.setMeasurements(82,70,28.4f); weatherData.setMeasurements(83,72,27.5f); &#125;&#125; Uml类图如下： 结果如下： 可以看到每次Subject变化，Observer跟着变化。 3. 观察者模式总结（conclusion） 以上实例可以看出来，观察者模式实现了Obseerver和Subject的解耦，Subject可以增删任意Observer,而Observer可以订阅任意的Subject。很好的满足了这种需求。这让我activemq，它其中就有一种发布订阅模式，在这里面生产者产生的消息，都能理解被消费者立即订阅到。可以看的出来这种思想应用的还是很广的。附上对应的github地址： https://github.com/maskwang520/designpattern.git]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式1-策略模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 1. 为什么需要策略模式 考虑到如下一个场景，你构造一个Duck的SuperClass,以后各种各样的鸭子都继承该SuperClass ,代码实现应该如下。12345678910111213public class Duck &#123; public void quack()&#123; //会叫 System.out.println("I can quack"); &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 具体的实现类如下123456789101112public class GreeHeadDuck extends Duck &#123; //绿头鸭 @Override public void play()&#123; System.out.println("I am green duck"); &#125;&#125;public class RedHeadDuck extends Duck&#123; //红头鸭 @Override public void play()&#123; System.out.println("I am red duck"); &#125;&#125; 上面这样看起来也没毛病啊，但是它有个问题就是，当给SuperClass加上fly()方法后，表示每个子类都会飞。即便是我后来的子类不能飞，它也可以fly。此时，我们可能会想到，覆盖fly()方法，方法里面什么都不做。但是问题还是很突出。原因如下： 代码在多个子类中重复。不管是什么类型的鸭子，都会继承来SuperClass的所有属性和方法，这其中有些子类根本就不具备。 运行时的行为不容易改变。我想让某个鸭子换个叫声，在不动SuperClass的情况下做不到。 很难知道所有鸭子共同的行为。比如fly方法，有些鸭子不具备，但是还是在父类中。 改一发动全身，我上面还是只添加fly(),有些鸭子不会飞，但是要覆盖方法。 我们接着可能会采用如下的解决办法，把fly,display从超类中抽出来，放进一个Flayable接口中。把quack()抽出来，放进Quackable接口中，代码如下。123456public interface Quackable &#123; //会叫的接口 public void quack();&#125;public interface Flyable &#123; //会飞接口 public void fly();&#125; 这样对于多个会飞Duck子类，每个子类都有一个实现Flyable()的类，在里面覆写fly()方法，会造成太多Flyable()的子类，无法复用。其次，还不能动态改变fly行为，因为已经写死啦。此时，设计原则就出来了，即：找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混到一起。 2. 如何使用策略模式 解决上述问题的根本是分开变化和不会变化的部分。Duck类中的fly(),quack()会随着鸭子的不同而改变，那我们将它们从Duck类中取出来，建立一组新类来代表每个行为。此时，设计原则就应用上了即，针对接口编程，而不是针对实现编程 这句话的理解在这里就是针对超类编程。前面我们设计 Quackable，Flyable，然后让具体的类去实现这两个接口，这样，就是针对实现编程，不利于动态修改和以后的拓展。因此，我们编写两个FlyBehavior,QuackBehavior两个接口，以及他们的实现类，这样，我们把FlyBehavior和QuackBehavior作为超类的属性，这个具体的实现通过set方法通过set()传递进去，这样实现面向接口编程，可以动态改变，也可以复用代码。代码实现如下：行为接口123456public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125; 实现类12345678910111213141516171819202122232425public class FlyNoWay implements FlyBehavior &#123; //不能飞 @Override public void fly() &#123; System.out.println("I can FlyNoWay"); &#125;&#125;public class FlyWithWins implements FlyBehavior &#123; //用翅膀飞 @Override public void fly() &#123; System.out.println("i can fly with wins"); &#125;&#125;public class Quack implements QuackBehavior &#123; //一般的叫 @Override public void quack() &#123; System.out.println("quack"); &#125;&#125;public class Squack implements QuackBehavior &#123; //嘶叫 @Override public void quack() &#123; System.out.println("squack"); &#125;&#125; 把基本接口作为超类的属性成员，面向接口编程12345678910111213141516171819202122232425262728public class Duck &#123; private FlyBehavior flyBehavior; //代理类，组合模式 private QuackBehavior quackBehavior; public void fly()&#123; flyBehavior.fly(); &#125; public void quack()&#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 测试类如下123456789public class Main &#123; public static void main(String[] args) &#123; Duck duck=new Duck(); duck.setFlyBehavior(new FlyNoWay()); duck.fly(); duck.setFlyBehavior(new FlyWithWins()); duck.fly(); &#125;&#125; 结果如下图 总结：上述做法的好处，面对不同飞行类型，可以在不修改Duck的基础上实现，这就是策略模式，根据你传入进来的具体实现类，执行不同的行为，这里关键就是运用多态这一特点。其次，不同的实现类可以复用，以前针对每个子类都有实现类，现在同一类型的都可以采用同一个实现类。 3. 结论 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，简单来说，就是定义了基础接口封装在类属性里面，可以根据不同的实现类，动态的改变行为。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>