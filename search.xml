<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot构建自定义的starter]]></title>
    <url>%2F2017%2F11%2F04%2FSpring-boot%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84starter%2F</url>
    <content type="text"><![CDATA[在我们日常用springboot的开发过程中，经常会遇到使用如下的一个类来代表程序的入口类。即123456@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 包括我自己，我平常在开发的过程中，并没有去重点关注spring boot的运行原理，大家都是约定俗成的这么去使用。接下的过程中，将会结合源码简单的分析下springboot运行原理。 一.Springboot 自动配置原理分析 @SpringBootApplication注解@SpringBootApplication是一个复合注解，它包括@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。其中最关键的莫过@EnableAutoConfiguration这个注解。在它的源码中加入了这样一个注解@Import({EnableAutoConfigurationImportSelector.class})，EnableAutoConfigurationImportSelector,它使用SpringFactoriesLoader. loadFactoryNames方法来扫描META-INF/spring.factories文件，此文件中声明了有哪些自动配置。源码如下（我挑选出重要的一部分）1234567891011121314151617181920public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException("Unable to load [" + factoryClass.getName() + "] factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex); &#125; &#125; 我随便查看spring-boot-autoconfigure-1.5.3.RELEASE.jar中的spring.factories,有如下的自动配置。123456# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ 上述spring.factories对应key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值即为启动时候需要自动配置的类。 二. 实现自定义的starter 首先定义一个基本的对象类，用来接收application.properties里面特定字段的值。12345678910111213@ConfigurationProperties(prefix = "hello")public class HelloServiceProperties &#123; private static final String MSG="world"; private String msg=MSG; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; @ConfigurationProperties(prefix = &quot;hello&quot;)是类型安全的属性获取。在application.properties 中通过hello.msg来设置，如果不设置默认就是“word”。 定义条件类（根据此类的存在与否来创建这个类的Bean，这个类可以是第三方类库的类）。 123456789public class HelloService &#123; private String msg; public String sayHello()&#123; return msg; &#125; public void setMsg(String msg)&#123; this.msg=msg; &#125;&#125; 自动配置类 1234567891011121314151617@Configuration //1@EnableConfigurationProperties(HelloServiceProperties.class)//2@ConditionalOnClass(HelloService.class) //3@ConditionalOnProperty(prefix = "hello",value = "enabled",matchIfMissing = true) //4public class HelloServiceAutoConfiguration &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean @ConditionalOnMissingBean(HelloService.class) //5 public HelloService helloService()&#123; HelloService helloService=new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; @Configuration 它告知 Spring 容器这个类是一个拥有 bean 定义和依赖项的配置类。 @EnableConfigurationProperties的bean可以以标准方式被注册(例如使用 @Bean 方法),即我定义HelloServiceProperties可以作为标准的Bean被容器管理。 @ConditionalOnClass表示该类在类路径下存在，自动配置该类下的Bean。 @ConditionalOnProperty当指定的属性等于指定的值的情况下加载当前配置类，在这里如果matchIfMissing如果为false，则在application.properties中必须存在hello.enable(且不能为false) @ConditionalOnMissingBean()表示指定的bean不在容器中，则重新新建@Bean注解的类，并交给容器管理。 配置好之后，我们还需要在src\main\resources下新建文件夹WEB-INF，再新建文件spring.factories里面的内容如下12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.springboot.mystartertool.HelloServiceAutoConfiguration 里面指定的类是上面自定义的那个配置类HelloServiceAutoConfiguration 定义spring.factories的原因是因为@EnableAutoConfiguration会扫描jar包下所有spring.factories文件，从而构造自动配置类。我们使用的时候使用@Autowired注入就行。 在以上工作完成后，我们执行如下命令1mvn clean install 就将项目打包到本地maven仓库中，有条件的可以安装的到私服中。 三. 应用自定义starter 首先引入自定义的starter的jar包 123456&lt;!--引入我的start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.maskwang&lt;/groupId&gt; &lt;artifactId&gt;Springboot-mystart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 当我们在application.properties配置如下 1hello.msg=maskwang 我们就可以使用自定义的starter啦。 123456789@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping("/hello") public String hello() &#123; return helloService.sayHello(); &#125;&#125; 由于我们没有自定义HelloService，所以会配置类会发挥作用，新建一个HelloService,并把里面的msg设置成”maskwang”。没有配置msg，则会采用默认的。结果如下 参考文献： 使用 Java 配置进行 Spring bean 管理 Spring boot实战（汪云飞著）github地址]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式4-工厂模式]]></title>
    <url>%2F2017%2F11%2F03%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在我平常的工作中我们往往会写下如下的代码。1234567891011public Pizza orderPizza(String type) &#123; Pizza pizza = new Pizza(); //以下是变化的部分 if (type.equals("chesss")) &#123; pizza = new ChessPizza(); &#125; else if (type.equals("clam")) &#123; pizza = new CalmPizza(); &#125; pizza.bake(); return pizza; &#125; 以上代码的问题在于我们要增加种类的时候，需要打开这段代码进行修改。这样造成系统难以维护，也更容易犯错。我们对拓展开放，对修改关闭。通常这种情况下，应该抽象出变化的部分。 2.如何实现工厂模式。 我们首先实现一个简单工厂模式 抽象出变化的部分，就是工厂 1234567891011public class SimplePIizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); &#125; else if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); &#125; return pizza; &#125;&#125; 调用的时候只需要用简单工厂生成就行 12345678910111213public class PizzaStroe &#123; SimplePIizzaFactory simplePIizzaFactory; public PizzaStroe(SimplePIizzaFactory simplePIizzaFactory) &#123; this.simplePIizzaFactory = simplePIizzaFactory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza =simplePIizzaFactory.createPizza(type); pizza.bake(); return pizza; &#125;&#125; 上面这样做的好处在于抽象出变化的部分，供其他部分调用 。另外，当我们需要修改的时候，只需要修改工厂类，其他的部分就不需要变动。 工厂模式（真正意义上的工厂模式） 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 定义一个基本的工厂基类和它的子工厂类12345678910111213141516171819202122232425262728293031323334//定义抽象的Pizza类public abstract class Pizza &#123; public String name; public ArrayList&lt;String&gt; ingredent=new ArrayList&lt;&gt;(); void prepare()&#123; System.out.println("Prepare: "+name); for(int i=0;i&lt;ingredent.size();i++)&#123; System.out.print(ingredent.get(i)+" "); &#125; &#125; void bake()&#123; System.out.println("Pizza is baking"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ArrayList&lt;String&gt; getIngredent() &#123; return ingredent; &#125; public void setIngredent(ArrayList&lt;String&gt; ingredent) &#123; this.ingredent = ingredent; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class PizzaStroe &#123; public Pizza orderPizza(String type) &#123; //不用管子类是什么 Pizza pizza = createPizza(type); pizza.bake(); return pizza; &#125; //定义抽象方法，由子类来实现 public abstract Pizza createPizza(String type);&#125;//武汉的工厂类，生产出武汉style的Pizzapublic class WuhanPizzaStore extends PizzaStroe &#123; @Override public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); pizza.ingredent.add("WuhanStyle"); &#125; else if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); pizza.ingredent.add("WuhanStyle"); &#125; return pizza; &#125;&#125;//北京的工厂类，生产出北京style的Pizzapublic class BeijingPizzaStore extends PizzaStroe &#123; @Override public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); pizza.ingredent.add("BeijingStyle"); &#125; else if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); pizza.ingredent.add("BeijingStyle"); &#125; return pizza; &#125;&#125; 当我们需要Pizza的时候，只需要用那个工厂类就可以构造出那种风格的Pizza1234567891011public class PizzaTest &#123; public static void main(String[] args) &#123; PizzaStroe beijingPizzaStore=new BeijingPizzaStore(); PizzaStroe wuhanPizzaStore=new WuhanPizzaStore(); Pizza pizza1=beijingPizzaStore.orderPizza("CalmPizza"); Pizza pizza2=wuhanPizzaStore.orderPizza("CalmPizza"); System.out.println(pizza1.getName()); System.out.println(pizza2.getName()); &#125;&#125; 来看下类图的关系 &emsp;&emsp;简单工厂与工厂方法的区别：简单工厂把全部的事情在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定如何实现。简单工厂的做法，可以将对象的创建封装起来，但是简单工厂不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。 抽象工厂模式首先给出定义 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 首先我们定义抽象接口1234public interface PropertyFactory &#123; public String getName(); public ArrayList&lt;String&gt; getIngredent();&#125; 在实际的场合中，抽象接口里面的抽象方法都是返回某个想要创建的抽象类，我这里比较简单，直接返回字符串和集合。之所以称为抽象工厂，我们从这里就可以看出来。通过抽象的方法，返回你希望得到的类的基类。 我们构造抽象工厂类的实现类12345678910111213141516171819202122232425262728public class CalmPropertyFactory implements PropertyFactory &#123; @Override public String getName() &#123; return "NewCalmPizza"; &#125; @Override public ArrayList&lt;String&gt; getIngredent() &#123; ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add("Newcalm"); return arrayList; &#125;&#125;public class ChessPropertyFactory implements PropertyFactory &#123; @Override public String getName() &#123; return "NewChessPizza"; &#125; @Override public ArrayList&lt;String&gt; getIngredent() &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add("Newchess"); return arrayList; &#125;&#125; 那么此时的Pizza的子类应该如此构造12345678public class CalmPizza extends Pizza &#123; PropertyFactory propertyFactory; public CalmPizza(PropertyFactory propertyFactory) &#123; this.propertyFactory=propertyFactory; name=propertyFactory.getName(); ingredent=propertyFactory.getIngredent(); &#125;&#125; 直接用对应的原料工厂来构造。来看下类图。 个人总结（conclusion)&emsp;&emsp;通过以上的描述，我们很容易明白工厂模式，也很容易区分简单工厂和工厂模式的区别（即构造类是在一个工厂类里面统一构造，还是通过子类的工厂方法来构造）。但是令人迷惑的是工厂模式与抽象工厂模式有什么区别。区别如下： 抽象工厂的每个方法实际上看起来都像是工厂方法，每个方法都被声明成抽象。而子类的方法来覆盖这些方法来创建某些对象。注意到，这里的子类是想要构造类的成分，就像我上面的写的name和ingredent成员。Pizza的子类只需要依赖依赖这些成分工厂类，例如ChessPropertyFactory ，就能构造出对象。重点突出抽象，是因为它有一个总的抽象接口，实现它的子类负责构造对象的成分，总而构成对象。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式3-装饰者模式]]></title>
    <url>%2F2017%2F10%2F15%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在我们的工作中，往往会这样的需求，就是动态地将责任附加到对象上，来达到拓展对象功能的目的。例如，对于做饼这件事来说，往往在做好一个饼之后，会有加糖，加盐，加鸡蛋这样类似的客户需求，不同的需求价格当然不同。我们通常的做法创建基类（Cake），然后让其他的子类继承它，试想下，如果如果有很多的类，岂不是会造成类爆炸，新出一款新的饼，就会构造一个类，计算不同的价格。而装饰者模式应用在这上面就非常的好。你想加糖，那我在外面包装一层，把额外的价格加上去。以后如果有几种配料的叠加，不用创造新的类，由原来的子类通过装饰者模式包装起来就行。 2. 如何实现装饰者模式how) 定义一个饼的基类，其他的饼的种类继承它。12345678910public abstract class Cake &#123; public String message="CAKE"; public float cost; public String getMessage()&#123; return message; &#125; //每个实现类自己实现 public abstract float getCost();&#125; 油饼，和糖饼分别实现饼1234567891011121314151617181920212223public class BatterCake extends Cake &#123; public BatterCake() &#123; message="batterCake"; &#125; @Override public float getCost() &#123; this.cost=1.2f; return cost; &#125;&#125;public class OilCake extends Cake&#123; //饼的实现类，油饼 public OilCake() &#123; message="oilCake"; &#125; @Override public float getCost() &#123; this.cost=1.5f; return cost; &#125;&#125; 可以分别加糖或者加盐，因此先来个装饰器接口 123public abstract class CakeDecorator extends Cake &#123; &#125; &emsp;&emsp;分别实现通过装饰器加糖和加盐 12345678910111213141516171819202122/** * Created by maskwang on 2017/10/15 0015. * 饼加盐 */public class SaltDecorator extends CakeDecorator&#123; Cake cake; public SaltDecorator(Cake cake) &#123; this.cake = cake; &#125; @Override public String getMessage() &#123; return cake.getMessage()+" with salt "; &#125; @Override public float getCost() &#123; return cake.getCost()+0.3f; &#125;&#125; 1234567891011121314151617public class SugerDecorator extends CakeDecorator &#123; Cake cake; public SugerDecorator(Cake cake) &#123; this.cake = cake; &#125; @Override public String getMessage() &#123; return cake.getMessage()+" with suger "; &#125; @Override public float getCost() &#123; return cake.getCost()+0.2f; //饼的钱+糖的钱 &#125;&#125; 测试一下通过装饰器既加糖又加盐123456789public class Test &#123; public static void main(String[] args) &#123; Cake cake = new OilCake(); cake = new SaltDecorator(cake); cake=new SugerDecorator(cake); System.out.println(cake.getMessage()); System.out.println(cake.getCost()); &#125;&#125; 结果如下： &emsp;&emsp;这里解释一下，最后的2.0如何出来，构造出OilCake，cost就是1.5， cake = new SaltDecorator(cake)，那么cost就是1.8。cake=new SugerDecorator(cake)，那么就是2.0。 我们常见到的IO包下，就运用到装饰者模式，例如BufferedInputStream,DataInputStream等。也可以实现一个装饰器，把字母转化成小写。如下：12345678910111213141516171819202122232425262728293031package com.designpattern.decoratorpattern;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;/** * Created by maskwang on 2017/10/15 0015. */public class UperCaseInputStream extends FilterInputStream &#123; public UperCaseInputStream(InputStream in) &#123; super(in); &#125; @Override public int read() throws IOException &#123; int c=super.read(); return (c==-1?c:Character.toUpperCase((char)c)); &#125; @Override public int read(byte[] b, int off, int len) throws IOException &#123; int result=super.read(b,off,len); for(int i=off;i&lt;off+result;i++)&#123; b[i]=(byte)Character.toUpperCase((char)b[i]); &#125; return result; &#125;&#125; 测试IO装饰类1234567891011121314151617 public static void main(String[] args) throws IOException &#123;// Cake cake = new OilCake();// cake = new SaltDecorator(cake);// cake=new SugerDecorator(cake);// System.out.println(cake.getMessage());// System.out.println(cake.getCost()); int c; try &#123; InputStream in=new UperCaseInputStream(new BufferedInputStream(new FileInputStream("E:\\test.txt"))); while ((c=in.read())&gt;0) System.out.println((char)(c)); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;![Uploading image_647020.png . . .] 3. 总结（conclution) &emsp;&emsp;从上述我们可以看出来 ，装饰者模式用于已经存在的类添加额外的功能，但是它也有缺点，就是它要在设计中加入大量的小类，会造成额外的空间占用。其核心思想还是如下： &emsp;&emsp;多用组合，少用继承。针对接口编程，不针对实现编程。对拓展开放，对修改关闭。github地址：github.com/maskwang520]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot用WebSocket构建交互式的web应用]]></title>
    <url>%2F2017%2F10%2F12%2FSpringboot%E7%94%A8WebSocket%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebSocket是html5带来的一项重大的特性，使得浏览器与服务端之间真正长连接交互成为了可能，这篇文章会带领大家窥探一下Spring 对WebSocket的支持及使用。 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭HTTP协议的长连接和短连接，这两种实质上是TCP协议的长连接和短连接。 项目结构 12345678910111213└── src └── main └── java └── hello └── config └── WebsocketConfig.java └── controller └── GreetingController.java └── message └── Greeting.java └── HelloMessage.java └──test └── pom.xml 1.Maven引入Jar包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;sprigboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.编写客户端发送的消息和服务端回复的消息Java类1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class HelloMessage &#123; String name; public HelloMessage() &#123; &#125; public HelloMessage(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class Greeting &#123; String content; public Greeting() &#123; &#125; public Greeting(String content) &#123; this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 注意在上面要有默认的构造器，没有的话，则会出现下面问题 这是因为序列化后，如果没有默认的构造器，则会让Springboot的默认序列化Jackson不能构造成原来的对象，反序列化还是需要通过默认的构造器来实现的 。客户端发送HelloMessage,服务端服务以Greeting。 ####3.Websocket配置类12345678910111213141516171819202122232425262728package hello.config;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;/** * Created by maskwang on 2017/10/12 0012. */@Configuration@EnableWebSocketMessageBrokerpublic class WebsocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123; @Override public void configureMessageBroker(MessageBrokerRegistry config) &#123; //客户端接收服务端消息的地址的前缀信息（客户端接受） config.enableSimpleBroker("/topic"); //客户端给服务端发消息的地址的前缀（客户端发送） config.setApplicationDestinationPrefixes("/app"); &#125; //这个方法的作用是添加一个服务端点，来接收客户端的连接。并开启SockJS的支持。 @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint("/socket").withSockJS(); &#125;&#125; registry.addEndpoint(“/socket”)表示添加了一个/socket端点，客户端和服务端就可以通过这个端点来进行连接。 withSockJS()的作用是开启SockJS支持 @EnableWebSocketMessageBroker别忘了。 configureMessageBroker(MessageBrokerRegistry config)定义消息代理，也就是服务端和客户端他们之间交换消息的规范。config.enableSimpleBroker(“/topic”);表明客户端接受服务端的消息时候，服务端的请求地址前缀。config.setApplicationDestinationPrefixes(“/app”)表明服务端接受客户端时候，客户端的请求地址前缀。4. 编写业务代码12345678910111213141516171819202122package hello.controller;import hello.messaage.Greeting;import hello.messaage.HelloMessage;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.stereotype.Controller;/** * Created by maskwang on 2017/10/12 0012. */@Controllerpublic class GreetingController &#123; @MessageMapping("/hello") //转发给服务端 @SendTo("/topic/greetings") public Greeting greeting(HelloMessage message) throws Exception &#123; Thread.sleep(1000); // simulated delay return new Greeting("Hello, " + message.getName() + "!"); &#125;&#125; @SendTo(“/topic/greetings”)是客户端发起连接后，订阅服务端消息时指定的一个地址，用于接收服务端的返回，也就是服务端返回的消息在客户端在订阅这个地址的消息后，客户端可以收到。定义怎样的客户端。 @MessageMapping(“/hello”)定义这个地址客户端发送的消息就会被映射这样的服务端。也就是客户端寻找那个服务端。定义了什么样的服务端。 理解上面两点很重要，后面都与这有关。 5. 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello WebSocket&lt;/title&gt; &lt;link href="/webjars/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link href="/main.css" rel="stylesheet"&gt; &lt;script src="/webjars/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/sockjs-client/1.0.2/sockjs.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/stomp-websocket/2.3.3/stomp.min.js"&gt;&lt;/script&gt; &lt;script src="/app.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;h2 style="color: #ff0000"&gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;&lt;div id="main-content" class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="connect"&gt;WebSocket connection:&lt;/label&gt; &lt;button id="connect" class="btn btn-default" type="submit"&gt;Connect&lt;/button&gt; &lt;button id="disconnect" class="btn btn-default" type="submit" disabled="disabled"&gt;Disconnect &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;What is your name?&lt;/label&gt; &lt;input type="text" id="name" class="form-control" placeholder="Your name here..."&gt; &lt;/div&gt; &lt;button id="send" class="btn btn-default" type="submit"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;table id="conversation" class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Greetings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="greetings"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var stompClient = null;function setConnected(connected) &#123; $("#connect").prop("disabled", connected); $("#disconnect").prop("disabled", !connected); if (connected) &#123; $("#conversation").show(); &#125; else &#123; $("#conversation").hide(); &#125; $("#greetings").html("");&#125;function connect() &#123; var socket = new SockJS('/socket'); //链接socket stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content); &#125;); &#125;);&#125;function disconnect() &#123; if (stompClient !== null) &#123; stompClient.disconnect(); &#125; setConnected(false); console.log("Disconnected");&#125;function sendName() &#123; stompClient.send("/app/hello", &#123;&#125;, JSON.stringify(&#123;'name': $("#name").val()&#125;));&#125;function showGreeting(message) &#123; $("#greetings").append("&lt;tr&gt;&lt;td&gt;" + message + "&lt;/td&gt;&lt;/tr&gt;");&#125;$(function () &#123; $("form").on('submit', function (e) &#123; e.preventDefault(); &#125;); $( "#connect" ).click(function() &#123; connect(); &#125;); $( "#disconnect" ).click(function() &#123; disconnect(); &#125;); $( "#send" ).click(function() &#123; sendName(); &#125;);&#125;); 前端我们需要用到两个js文件：sockjs.js和stomp.js SockJS：SockJS 是一个浏览器上运行的 JavaScript 库，如果浏览器不支持 WebSocket，该库可以模拟对 WebSocket 的支持，实现浏览器和 Web 服务器之间低延迟、全双工、跨域的通讯通道。StompStomp 提供了客户端和代理之间进行广泛消息传输的框架。Stomp 是一个非常简单而且易用的通讯协议实现，尽管代理端的编写可能非常复杂，但是编写一个 Stomp 客户端却是很简单的事情，另外你可以使用 Telnet 来与你的 Stomp 代理进行交互。 开启Socket var socket = new SockJS(‘/socket’); 先构建一个SockJS对象 stompClient = Stomp.over(socket); 用Stomp将SockJS进行协议封装 stompClient.connect()与服务端进行连接，同时有一个回调函数，处理连接成功后的操作信息。发送消息 stompClient.send(“/app/hello”, {}, JSON.stringify({‘name’: $(“#name”).val()}));是客户端向服务端发送消息 stompClient.subscribe(‘/topic/greetings’, function (greeting) { showGreeting(JSON.parse(greeting.body).content); }); //是服务端向客户端发送消息 点击connect后，发动任何message,服务端都会延迟一秒后，回复hello,message! 参考文献 HTTP长连接和短连接 Spring官方websocket例子 Spring WebSocket初探1 (Spring WebSocket入门教程)]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弄懂Fail-Safe,Fail-First]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%BC%84%E6%87%82Fail-Safe-Fail-First%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天在做算法题的时候，碰到的如下问题，记录下来加深记忆。很多时候我们都有这样一个需求，在迭代的时候（满足某个给定的条件）添加或者删除元素。结果却是等来了java.util.ConcurrentModificationException这个异常，追踪其原因，就是有些容器是Fail-Safe，Fail-First的12345678910111213public class CollectionTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (int a : arrayList) &#123; if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125;&#125; 1. Fail-Safe,Fail-First概念。 在ArrayList的里面有个内部类Itr。当我们获取到迭代器的时候，就会对这个类进行初始化，来看下这个类的源码，分析初始化做了些什么。123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 在初始化的时候，它会让expectedModCount = modCount，modCount在AbstractList，每次对ArrayList的结构性改变（remove,add）都会使得modCount相应的减1或者加1。来分析下我们刚开始出现问题的代码。当我们获取到迭代器的时候，此时expectedModCount = modCount。当remove的时候，modCount会加1，但是expectedModCount却不变，当执行Itr的next()操作时候，会执行上述源码中的checkForComodification()来检查expectedModCount = modCount，若不相等，则会throw ConcurrentModificationException。所以就不难分析出上述问题。 FailFirst:当我们在迭代获取集合元素的时候，在迭代器创建之后，对集合做一些结构性的改变（remove,add操作)，那么FailFirst容器首先会抛出 ConcurrentModificationException。 2. 如何解决上述问题。12345678910111213public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); ArrayList sub=new ArrayList(); for(int a:arrayList)&#123; if(a==1) sub.add(a); &#125; arrayList.removeAll(sub); System.out.println(arrayList); &#125; 上述这个办法好，但是却占额外空间。1234567891011121314public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) iterator.remove(); &#125; System.out.println(arrayList); &#125; 这样就不占额外的空间，是更好的办法。 iterator.remove()为啥不会抛异常，看看源码1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; expectedModCount = modCount;这句起作用，它删除元素后它会强制满足条件。所以不会抛异常。 3. Fail-First的出场 。 将刚开始的代码换成如下的形式,问题迎刃而解。1234567891011121314public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;Integer&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125; 像CopyOnWriteArrayList这类容器就属于Fail-Safe容器。当集合结构改变的时候不会抛出异常，这是因为他们只是原始集合的复制，它用snapshot这个数组来保存集合。所以你原始集合的修改只会让原来的引用指向新的数组，而旧的引用还是被迭代器的snapshot所引用。因而他们属于Fail-Safe容器。看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; private boolean remove(Object o, Object[] snapshot, int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 从上面可以看出每次添加元素都是线程安全的，因为加了锁。另外，每添加一个元素，都会把原来的引用指向一个新的数组。所以对他进行操作没问题。所以使用Fail-Safe容器也是一种很好的解决办法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式2---观察者模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的开发工作中，经常会遇到这样的问题。例如：对于A，对象B，C在原来引用了A。现在对象A的属性发生了变化，我们的需求是B，C能够同时感应到这种变化。且新增的对象D，也要引用A对象，那如何在不改变原来代码的基础上，如何做到呢。此时，观察者模式就能够很好的解决这个问题。 1. 为何需要观察者模式（why) Defidition:观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 下面通过一个和实例逐步弄清楚什么是观察者模式。 2. 如何实现观察者模式（通过实例来讲解how） 某气象站有这样一个应用：它实时检测当地温度，适度，压强。并让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都能实时更新相应的数据。气象站提供的数据结构如下。123456public class WeatherData &#123; float temp; float humidity; float pressture;//省略get,set方法&#125; 我们想到的办法就是让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都成为气象站的观察者，他们只需要在气象站注册，当气象站的数据发生变化的时候，会遍历每个观察者，调用update（）实现更新操作。step1:定义抽象接口1234567891011121314151617181920public interface Subject &#123; //主题，即气象站的抽象接口 //注册观察者 public void registerObserver(Observer o); //取消观察者 public void removeObserver(Observer o); //通知观察者执行更新操作 public void notifyObservers();&#125;public interface Observer &#123; //更新操作，等待Subject调用就实现了通知 public void update(float temp,float humidy,float pressure);&#125;public interface DisplayElement &#123; //对更新进行展示 public void display();&#125; 上述是接口，便于代码重用和面向接口编程，而不是面向实现编程。step2:实现具体的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressture; public WeatherData()&#123; observers=new ArrayList(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i=observers.indexOf(o); if(i&gt;=0) observers.remove(i); &#125; @Override public void notifyObservers() &#123; observers.stream().forEach((observer)-&gt;observer.update(temperature,humidity,pressture)); &#125; public void measurementsChanged()&#123;//通知 notifyObservers(); &#125; //属性改变了 public void setMeasurements(float temperature,float humidity,float pressture)&#123; this.temperature=temperature; this.humidity=humidity; this.pressture=pressture; measurementsChanged(); &#125;&#125; step3:Observer这里只提供一种实现，剩下的可以同样生成。123456789101112131415161718192021222324252627282930** * Created by maskwang on 2017/10/5 0005. * 时间原因这里只提供一种实现 */public class CurrentConditionsDisplay implements Observer,DisplayElement &#123; //这个观察者只在乎以下两个属性 private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this);//注册 &#125; @Override public void display() &#123; System.out.println(temperature+"**"+humidity); &#125; @Override public void update(float temp, float humidy, float pressure) &#123; this.humidity=humidy; this.temperature=temp; display(); &#125;&#125; step4:测试类12345678910111213public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); //订阅那个Object CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(80,65,30.2f); weatherData.setMeasurements(82,70,28.4f); weatherData.setMeasurements(83,72,27.5f); &#125;&#125; Uml类图如下： 结果如下： 可以看到每次Subject变化，Observer跟着变化。 3. 观察者模式总结（conclusion） 以上实例可以看出来，观察者模式实现了Obseerver和Subject的解耦，Subject可以增删任意Observer,而Observer可以订阅任意的Subject。很好的满足了这种需求。这让我activemq，它其中就有一种发布订阅模式，在这里面生产者产生的消息，都能理解被消费者立即订阅到。可以看的出来这种思想应用的还是很广的。附上对应的github地址： https://github.com/maskwang520/designpattern.git]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式1-策略模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 1. 为什么需要策略模式 考虑到如下一个场景，你构造一个Duck的SuperClass,以后各种各样的鸭子都继承该SuperClass ,代码实现应该如下。12345678910111213public class Duck &#123; public void quack()&#123; //会叫 System.out.println("I can quack"); &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 具体的实现类如下123456789101112public class GreeHeadDuck extends Duck &#123; //绿头鸭 @Override public void play()&#123; System.out.println("I am green duck"); &#125;&#125;public class RedHeadDuck extends Duck&#123; //红头鸭 @Override public void play()&#123; System.out.println("I am red duck"); &#125;&#125; 上面这样看起来也没毛病啊，但是它有个问题就是，当给SuperClass加上fly()方法后，表示每个子类都会飞。即便是我后来的子类不能飞，它也可以fly。此时，我们可能会想到，覆盖fly()方法，方法里面什么都不做。但是问题还是很突出。原因如下： 代码在多个子类中重复。不管是什么类型的鸭子，都会继承来SuperClass的所有属性和方法，这其中有些子类根本就不具备。 运行时的行为不容易改变。我想让某个鸭子换个叫声，在不动SuperClass的情况下做不到。 很难知道所有鸭子共同的行为。比如fly方法，有些鸭子不具备，但是还是在父类中。 改一发动全身，我上面还是只添加fly(),有些鸭子不会飞，但是要覆盖方法。 我们接着可能会采用如下的解决办法，把fly,display从超类中抽出来，放进一个Flayable接口中。把quack()抽出来，放进Quackable接口中，代码如下。123456public interface Quackable &#123; //会叫的接口 public void quack();&#125;public interface Flyable &#123; //会飞接口 public void fly();&#125; 这样对于多个会飞Duck子类，每个子类都有一个实现Flyable()的类，在里面覆写fly()方法，会造成太多Flyable()的子类，无法复用。其次，还不能动态改变fly行为，因为已经写死啦。此时，设计原则就出来了，即：找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混到一起。 2. 如何使用策略模式 解决上述问题的根本是分开变化和不会变化的部分。Duck类中的fly(),quack()会随着鸭子的不同而改变，那我们将它们从Duck类中取出来，建立一组新类来代表每个行为。此时，设计原则就应用上了即，针对接口编程，而不是针对实现编程 这句话的理解在这里就是针对超类编程。前面我们设计 Quackable，Flyable，然后让具体的类去实现这两个接口，这样，就是针对实现编程，不利于动态修改和以后的拓展。因此，我们编写两个FlyBehavior,QuackBehavior两个接口，以及他们的实现类，这样，我们把FlyBehavior和QuackBehavior作为超类的属性，这个具体的实现通过set方法通过set()传递进去，这样实现面向接口编程，可以动态改变，也可以复用代码。代码实现如下：行为接口123456public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125; 实现类12345678910111213141516171819202122232425public class FlyNoWay implements FlyBehavior &#123; //不能飞 @Override public void fly() &#123; System.out.println("I can FlyNoWay"); &#125;&#125;public class FlyWithWins implements FlyBehavior &#123; //用翅膀飞 @Override public void fly() &#123; System.out.println("i can fly with wins"); &#125;&#125;public class Quack implements QuackBehavior &#123; //一般的叫 @Override public void quack() &#123; System.out.println("quack"); &#125;&#125;public class Squack implements QuackBehavior &#123; //嘶叫 @Override public void quack() &#123; System.out.println("squack"); &#125;&#125; 把基本接口作为超类的属性成员，面向接口编程12345678910111213141516171819202122232425262728public class Duck &#123; private FlyBehavior flyBehavior; //代理类，组合模式 private QuackBehavior quackBehavior; public void fly()&#123; flyBehavior.fly(); &#125; public void quack()&#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 测试类如下123456789public class Main &#123; public static void main(String[] args) &#123; Duck duck=new Duck(); duck.setFlyBehavior(new FlyNoWay()); duck.fly(); duck.setFlyBehavior(new FlyWithWins()); duck.fly(); &#125;&#125; 结果如下图 总结：上述做法的好处，面对不同飞行类型，可以在不修改Duck的基础上实现，这就是策略模式，根据你传入进来的具体实现类，执行不同的行为，这里关键就是运用多态这一特点。其次，不同的实现类可以复用，以前针对每个子类都有实现类，现在同一类型的都可以采用同一个实现类。 3. 结论 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，简单来说，就是定义了基础接口封装在类属性里面，可以根据不同的实现类，动态的改变行为。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>