<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红黑树的原理和常见操作]]></title>
    <url>%2F2018%2F01%2F13%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 概述在jdk1.8中，HashMap和ConcurrentHashMap中都采用了红黑树这一数据结构。即当链表达到一定的长度后，就把链表转化成红黑树。这其中主要利用了红黑树的良好性质，不管你节点怎样，他始终保持查找时间复杂度为O(logn)。这样的性质相对于链表在长度很长的时候有很大的优势。O(logn）&lt;O(lgn) 2. 红黑树的定义 每个结点要么是红的，要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。 如果一个结点是红的，那么它的俩个儿子都是黑的。 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。一棵典型的红黑树如下： 3. 红黑树的插入在这里，默认你熟悉二叉查找树的结构，以及他的插入和删除操作。红黑树本质上是一棵二叉查找树。对红黑树的插入，我们先按二叉查找树去插入，然后对对树做调整，使其满足红黑树的五条定义。（这是因为你插入会破坏其中的规则）二叉查找树的插入伪代码如下：123456789101112131415161718RB-INSERT(T, z) 1 y ← nil[T] 2 x ← root[T] 3 while x ≠ nil[T] 4 do y ← x 5 if key[z] &lt; key[x] 6 then x ← left[x] 7 else x ← right[x] 8 p[z] ← y 9 if y = nil[T] 10 then root[T] ← z 11 else if key[z] &lt; key[y] 12 then left[y] ← z 13 else right[y] ← z 14 left[z] ← nil[T] 15 right[z] ← nil[T] 16 color[z] ← RED 17 RB-INSERT-FIXUP(T, z) 可以看出，RB-INSERT(T, z)前面的第1-13行代码基本就是二叉查找树的插入代码，然后第14-16行代码把z的左孩子、右孩子都赋为叶结点nil，再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。换言之 如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。 如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。 但当遇到下述3种情况时： 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色 插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子 插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子 3.1 插入修复情况1：当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。插入的伪代码如下：123456781 while color[p[z]] = RED 2 do if p[z] = left[p[p[z]]] 3 then y ← right[p[p[z]]] 4 if color[y] = RED 5 then color[p[z]] ← BLACK ▹ Case 1 6 color[y] ← BLACK ▹ Case 1 7 color[p[p[z]]] ← RED ▹ Case 1 8 z ← p[p[z]] ▹ Case 1 如下面两个调整前的图和调整之后的图做对比。其中4为新添加的点。它的父节点为红色，叔叔节点为红色。那么调整就是把4的叔叔节点变为黑色（8节点），4的祖父节点变为红色，把当前结点指向祖父结点，从新的当前结点重新开始算法（7节点变为N)。 3.2 插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子123 9 else if z = right[p[z]]10 then z ← p[z] ▹ Case 211 LEFT-ROTATE(T, z) ▹ Case 2 调整之前的图如3.1.2，经过调整后得到如下的图。过程是当前结点的父结点做为新的当前结点，以新当前结点为支点左旋. 3.3 插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子12312 color[p[z]] ← BLACK ▹ Case 313 color[p[p[z]]] ← RED ▹ Case 314 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 调整过程是把父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。最后，把根结点涂为黑色，整棵红黑树便重新恢复了平衡。调整之前的图如3.2.2，经过调整后得到下图。 3. 红黑树的删除在这里默认你熟悉二叉查找树的删除操作。 下面我们用一个分析技巧：我们从被删结点后来顶替它的那个结点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的结点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父结点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。”–saturnman。如果是以下情况，恢复比较简单： 当前结点是红+黑色解法，直接把当前结点染成黑色，结束此时红黑树性质全部恢复。 当前结点是黑+黑且是根结点， 解法：什么都不做，结束。 下面4中特殊情况 删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点分为黑) 删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色 删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色 删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意 4.1 删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点分为黑)。解法：把父结点染成红色，把兄弟结点染成黑色，之后重新进入算法（我们只讨论当前结点是其父结点左孩子时的情况）。此变换后原红黑树性质5不变，而把问题转化为兄弟结点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟结点为黑色的情况)。 4.2 删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色。 解法：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点，重新进入算法。（此变换后性质5不变）。伪代码如下。1234//调用RB-DELETE-FIXUP(T, x) 的9-11行代码9 if color[left[w]] = BLACK and color[right[w]] = BLACK10 then color[w] ← RED ▹ Case 211 x p[x] ▹ Case 2 4.3 删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色。解法：把兄弟结点染红，兄弟左子结点染黑，之后再在兄弟结点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持。伪代码如下123456//调用RB-DELETE-FIXUP(T, x) 的第12-16行代码12 else if color[right[w]] = BLACK13 then color[left[w]] ← BLACK ▹ Case 314 color[w] ← RED ▹ Case 315 RIGHT-ROTATE(T, w) ▹ Case 316 w ← right[p[x]] ▹ Case 3 4.4 删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意。解法：把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋，此时算法结束，红黑树所有性质调整正确。代码如下123456//调用RB-DELETE-FIXUP(T, x) 的第17-21行代码17 color[w] ← color[p[x]] ▹ Case 418 color[p[x]] ← BLACK ▹ Case 419 color[right[w]] ← BLACK ▹ Case 420 LEFT-ROTATE(T, p[x]) ▹ Case 421 x ← root[T] ▹ Case 4 以上就是红黑树的结构和性质，对于面试和源码的理解很有帮助。 参考文章：教你透彻了解红黑树]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jdk1.8 HashMap源码分析]]></title>
    <url>%2F2018%2F01%2F12%2FJdk1-8-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 概述平常我们开发中，可能用的最多的容器就是HashMap。我们来看下HashMap的结构如下图。它是由一个Node数组，每个数组元素又是有一个链表构成。接下来我们结合源码来分析下put(),get(),resize()者三个常见的操作。 2. 类成员变量的认识123456789static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // HashMap初始的bucket16.必须是2的n次幂，原因在后面会涉及到static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; //负载因子，估计整个bucket冲突，当到达bucket*0.75容量时，会引起扩容static final int TREEIFY_THRESHOLD = 8; //当链表长度大于这个值时，会转变成红黑树static final int UNTREEIFY_THRESHOLD = 6; //当树的节点低于这个值时会转变成链表 关于红黑树的介绍，参见我的下篇文章，红黑树的原理及常见的操作3. put()函数的解析put()添加操作的过程如下。 对key的hashCode()做hash，然后再计算index（求余）; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。其他的解释都在源码中标注。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public V put(K key, V value) &#123; //对key的hashcode做hash return putVal(hash(key), key, value, false, true); &#125;//onlyIfAbsent为true时，相同的key不会改变替换值。这里的为false，会替换//evict表示模式，为fasle表示处于bucket处于创建阶段。这里用true指创建完了。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //若为null,则创建bucket n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //若bucket那个位置为null,则创建新的Node节点 tab[i] = newNode(hash, key, value, null); //表示bucket不为null else &#123; Node&lt;K,V&gt; e; K k; //key存在 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //若原来为TreeNode,则插入到红黑树种中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //若原来为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //写入，若原来有值，则替换 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //若超过当前容量大小超过capacity*0.75，则会引起扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 注意这里采用的二次hash()操作,不是直接对hashcode再hash。123456//hashcode的低16位和高16位做异或操作static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 之所以这样hash，是采用key的hashcode的低16位和高16位做异或操作。这样的好处在于避免hash冲突。否则，它只取低16位，与高位无关，那么它有可能会hash冲突严重。另外，如果还有更严重的冲突，那么可以采用红黑树来解决，事实上Jdk1.8 HashMap也是采用的这样的思想。 Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. 4. get()的解析get()相对来说就非常简单了，过程如下。 bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //这个if判断bucket是否存在 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //检查第一个Node（bucket中第一个节点）是否是要查找的。 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //红黑树的查找key if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; //遍历链表，寻找key相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; (n - 1) &amp; hash就是一个求索引，即求Node数组中的下标。这样的操作是，当我们的n(表示capacity时)取2的幂的时候，例如n取16，那么n-1=15（二进制表示1111）与hash做与操作的时候相当于取余，这样做比直接取余更高效。 5. reSize()的解析 当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。 然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在(原位置+旧capacity)的位置。怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //旧的hashMap容量已经达到最大值，那么最新的也只能是最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果原来存在旧的容量存在，那么新分配的就是旧的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125;//旧的容量oldThreshold已经存在，但是没分配容量。那么久新的容量=oldThreshold else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //两个变量都没有初始化 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125;//如果初始化的oldThreshold为0，则重新取整 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //尾插法把节点插入新分配的bucket中。不带头节点的 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 参考文章： Java HashMap工作原理及实现 HashMap1.8源码解读 深入浅出ConcurrentHashMap1.8]]></content>
      <categories>
        <category>Java源码分析</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义注解实现Restful接口版本管理]]></title>
    <url>%2F2017%2F12%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0Restful%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的日常开发中，需求总是变化的。对于某个接口，随着需求的升级，也面临里面逻辑的变化。例如，对于/v1/hello,/v2/hello 两个请求，若存在相应的映射，则对应入座。否则都映射到最新的接口上。则映射到最新的接口上。此时，我们又想保持以前的接口还保留，那么我们此时需要做的事，把对接口的请求都映射到最新的接口上，而原来的接口请求还是映射原来的接口上。我在这里介绍用自定义注解的形式，在@RequestMapping()的映射原理上做文章。 自定义注解1234567@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface ApiVersion &#123; int value();&#125; &emsp;&emsp;就是定义一个简单的注解@ApiVersion，这个注解可以在类上和方法上都可以应用。 注解的识别12345678910111213141516171819public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping &#123; @Override // ① protected RequestCondition&lt;ApiVesrsionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); return createCondition(apiVersion); &#125; @Override //② protected RequestCondition&lt;ApiVesrsionCondition&gt; getCustomMethodCondition(Method method) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class); return createCondition(apiVersion); &#125; //③ 实例化RequestCondition private RequestCondition&lt;ApiVesrsionCondition&gt; createCondition(ApiVersion apiVersion) &#123; return apiVersion == null ? null : new ApiVesrsionCondition(apiVersion.value()); &#125;&#125; &emsp;&emsp;我们知道，光定义注解是没什么用的，重要的是我们识别到注解，做相应的事。RequestMappingHandlerMapping类是与 @RequestMapping相关的，它定义映射的规则。即满足怎样的条件则映射到那个接口上。 &emsp;&emsp;①处构建类级的映射要求，AnnotationUtils.findAnnotation根据在类上面的注解实例化一个注解类。然后构造RequestCondition。 &emsp;&emsp;②处构建类级的映射要求，AnnotationUtils.findAnnotation根据在方法上面的注解实例化一个注解类。然后构造RequestCondition。AnnotationUtils.findAnnotation是用到Spring的工具类，根据标注的注解识别注解。很方便，比通过反射的方式来找到注解要方便。 自定义条件类12345678910111213141516171819202122232425262728293031323334public class ApiVesrsionCondition implements RequestCondition&lt;ApiVesrsionCondition&gt; &#123; // 路径中版本的前缀， 这里用 /v[1-9]/的形式 private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile("v(\\d+)/"); private int apiVersion; public ApiVesrsionCondition(int apiVersion)&#123; this.apiVersion = apiVersion; &#125; //将不同的筛选条件合并,这里采用的覆盖，即后来的规则生效 public ApiVesrsionCondition combine(ApiVesrsionCondition other) &#123; return new ApiVesrsionCondition(other.getApiVersion()); &#125; //根据request查找匹配到的筛选条件 public ApiVesrsionCondition getMatchingCondition(HttpServletRequest request) &#123; System.out.println(request.getRequestURI()); Matcher m = VERSION_PREFIX_PATTERN.matcher(request.getRequestURI()); if(m.find())&#123; Integer version = Integer.valueOf(m.group(1)); if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足，即与请求的 return this; &#125; return null; &#125; //实现不同条件类的比较，从而实现优先级排序 public int compareTo(ApiVesrsionCondition other, HttpServletRequest request) &#123; return other.getApiVersion() - this.apiVersion; &#125; public int getApiVersion() &#123; return apiVersion; &#125;&#125; &emsp;&emsp;getMatchingCondition()利用正则表达式把请求路径中的/v1/hello中的1（版本号）找出来，然后返回与大于等于1的条件类。那么@RequestMapping则路由到产生该条件类的方法下。 测试123456789101112131415161718192021222324252627282930313233343536@RequestMapping("/&#123;version&#125;/")@Controllerpublic class VersionController &#123; @RequestMapping("hello") @ApiVersion(1) @ResponseBody public String hello()&#123; System.out.println("haha1.........."); return "hello version1"; &#125; @RequestMapping("hello") @ApiVersion(2) @ResponseBody public String hello2()&#123; System.out.println("haha2........."); return "hello version2"; &#125; @RequestMapping("hello") @ResponseBody @ApiVersion(5) public String hello5()&#123; System.out.println("haha5........."); return "hello version5"; &#125; @RequestMapping("test") @ResponseBody public String test()&#123; return "test"; &#125;&#125; &emsp;&emsp;每个方法上都用 @ApiVersion()注解啦。当在浏览器输入http://localhost:8761/v2/hello 则跳到hello2()方法中执行。当在浏览器输入http://localhost:8761/v5/hello 则跳到hello5()中执行，因为比5大的都调到最新hello5()执行。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot构建自定义的starter]]></title>
    <url>%2F2017%2F11%2F04%2FSpring-boot%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84starter%2F</url>
    <content type="text"><![CDATA[在我们日常用springboot的开发过程中，经常会遇到使用如下的一个类来代表程序的入口类。即123456@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 包括我自己，我平常在开发的过程中，并没有去重点关注spring boot的运行原理，大家都是约定俗成的这么去使用。接下的过程中，将会结合源码简单的分析下springboot运行原理。 一.Springboot 自动配置原理分析 @SpringBootApplication注解@SpringBootApplication是一个复合注解，它包括@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解。其中最关键的莫过@EnableAutoConfiguration这个注解。在它的源码中加入了这样一个注解@Import({EnableAutoConfigurationImportSelector.class})，EnableAutoConfigurationImportSelector,它使用SpringFactoriesLoader. loadFactoryNames方法来扫描META-INF/spring.factories文件，此文件中声明了有哪些自动配置。源码如下（我挑选出重要的一部分）1234567891011121314151617181920public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException("Unable to load [" + factoryClass.getName() + "] factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex); &#125; &#125; 我随便查看spring-boot-autoconfigure-1.5.3.RELEASE.jar中的spring.factories,有如下的自动配置。123456# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ 上述spring.factories对应key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值即为启动时候需要自动配置的类。 二. 实现自定义的starter 首先定义一个基本的对象类，用来接收application.properties里面特定字段的值。12345678910111213@ConfigurationProperties(prefix = "hello")public class HelloServiceProperties &#123; private static final String MSG="world"; private String msg=MSG; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; @ConfigurationProperties(prefix = &quot;hello&quot;)是类型安全的属性获取。在application.properties 中通过hello.msg来设置，如果不设置默认就是“word”。 定义条件类（根据此类的存在与否来创建这个类的Bean，这个类可以是第三方类库的类）。 123456789public class HelloService &#123; private String msg; public String sayHello()&#123; return msg; &#125; public void setMsg(String msg)&#123; this.msg=msg; &#125;&#125; 自动配置类1234567891011121314151617@Configuration //1@EnableConfigurationProperties(HelloServiceProperties.class)//2@ConditionalOnClass(HelloService.class) //3@ConditionalOnProperty(prefix = "hello",value = "enabled",matchIfMissing = true) //4public class HelloServiceAutoConfiguration &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean @ConditionalOnMissingBean(HelloService.class) //5 public HelloService helloService()&#123; HelloService helloService=new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; @Configuration 它告知 Spring 容器这个类是一个拥有 bean 定义和依赖项的配置类。 @EnableConfigurationProperties的bean可以以标准方式被注册(例如使用 @Bean 方法),即我定义HelloServiceProperties可以作为标准的Bean被容器管理。 @ConditionalOnClass表示该类在类路径下存在，自动配置该类下的Bean。 @ConditionalOnProperty当指定的属性等于指定的值的情况下加载当前配置类，在这里如果matchIfMissing如果为false，则在application.properties中必须存在hello.enable(且不能为false) @ConditionalOnMissingBean()表示指定的bean不在容器中，则重新新建@Bean注解的类，并交给容器管理。 配置好之后，我们还需要在src\main\resources下新建文件夹WEB-INF，再新建文件spring.factories里面的内容如下12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.springboot.mystartertool.HelloServiceAutoConfiguration 里面指定的类是上面自定义的那个配置类HelloServiceAutoConfiguration 定义spring.factories的原因是因为@EnableAutoConfiguration会扫描jar包下所有spring.factories文件，从而构造自动配置类。我们使用的时候使用@Autowired注入就行。 在以上工作完成后，我们执行如下命令1mvn clean install 就将项目打包到本地maven仓库中，有条件的可以安装的到私服中。 三. 应用自定义starter 首先引入自定义的starter的jar包1234567891011 &lt;!--引入我的start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.maskwang&lt;/groupId&gt; &lt;artifactId&gt;Springboot-mystart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;``` 2. 当我们在`application.properties`配置如下 ```Groovyhello.msg=maskwang 我们就可以使用自定义的starter啦。 123456789@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping("/hello") public String hello() &#123; return helloService.sayHello(); &#125;&#125; 由于我们没有自定义HelloService，所以会配置类会发挥作用，新建一个HelloService,并把里面的msg设置成”maskwang”。没有配置msg，则会采用默认的。结果如下 参考文献： 使用 Java 配置进行 Spring bean 管理 Spring boot实战（汪云飞著）github地址]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式4-工厂模式]]></title>
    <url>%2F2017%2F11%2F03%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在我平常的工作中我们往往会写下如下的代码。1234567891011public Pizza orderPizza(String type) &#123; Pizza pizza = new Pizza(); //以下是变化的部分 if (type.equals("chesss")) &#123; pizza = new ChessPizza(); &#125; else if (type.equals("clam")) &#123; pizza = new CalmPizza(); &#125; pizza.bake(); return pizza; &#125; 以上代码的问题在于我们要增加种类的时候，需要打开这段代码进行修改。这样造成系统难以维护，也更容易犯错。我们对拓展开放，对修改关闭。通常这种情况下，应该抽象出变化的部分。 2.如何实现工厂模式。 我们首先实现一个简单工厂模式 抽象出变化的部分，就是工厂 1234567891011public class SimplePIizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); &#125; else if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); &#125; return pizza; &#125;&#125; 调用的时候只需要用简单工厂生成就行 12345678910111213public class PizzaStroe &#123; SimplePIizzaFactory simplePIizzaFactory; public PizzaStroe(SimplePIizzaFactory simplePIizzaFactory) &#123; this.simplePIizzaFactory = simplePIizzaFactory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza =simplePIizzaFactory.createPizza(type); pizza.bake(); return pizza; &#125;&#125; 上面这样做的好处在于抽象出变化的部分，供其他部分调用 。另外，当我们需要修改的时候，只需要修改工厂类，其他的部分就不需要变动。 工厂模式（真正意义上的工厂模式） 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 定义一个基本的工厂基类和它的子工厂类12345678910111213141516171819202122232425262728293031323334//定义抽象的Pizza类public abstract class Pizza &#123; public String name; public ArrayList&lt;String&gt; ingredent=new ArrayList&lt;&gt;(); void prepare()&#123; System.out.println("Prepare: "+name); for(int i=0;i&lt;ingredent.size();i++)&#123; System.out.print(ingredent.get(i)+" "); &#125; &#125; void bake()&#123; System.out.println("Pizza is baking"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ArrayList&lt;String&gt; getIngredent() &#123; return ingredent; &#125; public void setIngredent(ArrayList&lt;String&gt; ingredent) &#123; this.ingredent = ingredent; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class PizzaStroe &#123; public Pizza orderPizza(String type) &#123; //不用管子类是什么 Pizza pizza = createPizza(type); pizza.bake(); return pizza; &#125; //定义抽象方法，由子类来实现 public abstract Pizza createPizza(String type);&#125;//武汉的工厂类，生产出武汉style的Pizzapublic class WuhanPizzaStore extends PizzaStroe &#123; @Override public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); pizza.ingredent.add("WuhanStyle"); &#125; else if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); pizza.ingredent.add("WuhanStyle"); &#125; return pizza; &#125;&#125;//北京的工厂类，生产出北京style的Pizzapublic class BeijingPizzaStore extends PizzaStroe &#123; @Override public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("CalmPizza")) &#123; pizza = new CalmPizza(); pizza.ingredent.add("BeijingStyle"); &#125; else if (type.equals("ChessPizza")) &#123; pizza = new ChessPizza(); pizza.ingredent.add("BeijingStyle"); &#125; return pizza; &#125;&#125; 当我们需要Pizza的时候，只需要用那个工厂类就可以构造出那种风格的Pizza1234567891011public class PizzaTest &#123; public static void main(String[] args) &#123; PizzaStroe beijingPizzaStore=new BeijingPizzaStore(); PizzaStroe wuhanPizzaStore=new WuhanPizzaStore(); Pizza pizza1=beijingPizzaStore.orderPizza("CalmPizza"); Pizza pizza2=wuhanPizzaStore.orderPizza("CalmPizza"); System.out.println(pizza1.getName()); System.out.println(pizza2.getName()); &#125;&#125; 来看下类图的关系 &emsp;&emsp;简单工厂与工厂方法的区别：简单工厂把全部的事情在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定如何实现。简单工厂的做法，可以将对象的创建封装起来，但是简单工厂不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。 抽象工厂模式首先给出定义 抽象工厂模式 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 首先我们定义抽象接口1234public interface PropertyFactory &#123; public String getName(); public ArrayList&lt;String&gt; getIngredent();&#125; 在实际的场合中，抽象接口里面的抽象方法都是返回某个想要创建的抽象类，我这里比较简单，直接返回字符串和集合。之所以称为抽象工厂，我们从这里就可以看出来。通过抽象的方法，返回你希望得到的类的基类。 我们构造抽象工厂类的实现类12345678910111213141516171819202122232425262728public class CalmPropertyFactory implements PropertyFactory &#123; @Override public String getName() &#123; return "NewCalmPizza"; &#125; @Override public ArrayList&lt;String&gt; getIngredent() &#123; ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add("Newcalm"); return arrayList; &#125;&#125;public class ChessPropertyFactory implements PropertyFactory &#123; @Override public String getName() &#123; return "NewChessPizza"; &#125; @Override public ArrayList&lt;String&gt; getIngredent() &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add("Newchess"); return arrayList; &#125;&#125; 那么此时的Pizza的子类应该如此构造12345678public class CalmPizza extends Pizza &#123; PropertyFactory propertyFactory; public CalmPizza(PropertyFactory propertyFactory) &#123; this.propertyFactory=propertyFactory; name=propertyFactory.getName(); ingredent=propertyFactory.getIngredent(); &#125;&#125; 直接用对应的原料工厂来构造。来看下类图。 个人总结（conclusion)&emsp;&emsp;通过以上的描述，我们很容易明白工厂模式，也很容易区分简单工厂和工厂模式的区别（即构造类是在一个工厂类里面统一构造，还是通过子类的工厂方法来构造）。但是令人迷惑的是工厂模式与抽象工厂模式有什么区别。区别如下： 抽象工厂的每个方法实际上看起来都像是工厂方法，每个方法都被声明成抽象。而子类的方法来覆盖这些方法来创建某些对象。注意到，这里的子类是想要构造类的成分，就像我上面的写的name和ingredent成员。Pizza的子类只需要依赖依赖这些成分工厂类，例如ChessPropertyFactory ，就能构造出对象。重点突出抽象，是因为它有一个总的抽象接口，实现它的子类负责构造对象的成分，总而构成对象。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式3-装饰者模式]]></title>
    <url>%2F2017%2F10%2F15%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在我们的工作中，往往会这样的需求，就是动态地将责任附加到对象上，来达到拓展对象功能的目的。例如，对于做饼这件事来说，往往在做好一个饼之后，会有加糖，加盐，加鸡蛋这样类似的客户需求，不同的需求价格当然不同。我们通常的做法创建基类（Cake），然后让其他的子类继承它，试想下，如果如果有很多的类，岂不是会造成类爆炸，新出一款新的饼，就会构造一个类，计算不同的价格。而装饰者模式应用在这上面就非常的好。你想加糖，那我在外面包装一层，把额外的价格加上去。以后如果有几种配料的叠加，不用创造新的类，由原来的子类通过装饰者模式包装起来就行。 2. 如何实现装饰者模式how) 定义一个饼的基类，其他的饼的种类继承它。12345678910public abstract class Cake &#123; public String message="CAKE"; public float cost; public String getMessage()&#123; return message; &#125; //每个实现类自己实现 public abstract float getCost();&#125; 油饼，和糖饼分别实现饼1234567891011121314151617181920212223public class BatterCake extends Cake &#123; public BatterCake() &#123; message="batterCake"; &#125; @Override public float getCost() &#123; this.cost=1.2f; return cost; &#125;&#125;public class OilCake extends Cake&#123; //饼的实现类，油饼 public OilCake() &#123; message="oilCake"; &#125; @Override public float getCost() &#123; this.cost=1.5f; return cost; &#125;&#125; 可以分别加糖或者加盐，因此先来个装饰器接口 123public abstract class CakeDecorator extends Cake &#123; &#125; &emsp;&emsp;分别实现通过装饰器加糖和加盐 12345678910111213141516171819202122/** * Created by maskwang on 2017/10/15 0015. * 饼加盐 */public class SaltDecorator extends CakeDecorator&#123; Cake cake; public SaltDecorator(Cake cake) &#123; this.cake = cake; &#125; @Override public String getMessage() &#123; return cake.getMessage()+" with salt "; &#125; @Override public float getCost() &#123; return cake.getCost()+0.3f; &#125;&#125; 1234567891011121314151617public class SugerDecorator extends CakeDecorator &#123; Cake cake; public SugerDecorator(Cake cake) &#123; this.cake = cake; &#125; @Override public String getMessage() &#123; return cake.getMessage()+" with suger "; &#125; @Override public float getCost() &#123; return cake.getCost()+0.2f; //饼的钱+糖的钱 &#125;&#125; 测试一下通过装饰器既加糖又加盐123456789public class Test &#123; public static void main(String[] args) &#123; Cake cake = new OilCake(); cake = new SaltDecorator(cake); cake=new SugerDecorator(cake); System.out.println(cake.getMessage()); System.out.println(cake.getCost()); &#125;&#125; 结果如下： &emsp;&emsp;这里解释一下，最后的2.0如何出来，构造出OilCake，cost就是1.5， cake = new SaltDecorator(cake)，那么cost就是1.8。cake=new SugerDecorator(cake)，那么就是2.0。 我们常见到的IO包下，就运用到装饰者模式，例如BufferedInputStream,DataInputStream等。也可以实现一个装饰器，把字母转化成小写。如下：12345678910111213141516171819202122232425262728293031package com.designpattern.decoratorpattern;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;/** * Created by maskwang on 2017/10/15 0015. */public class UperCaseInputStream extends FilterInputStream &#123; public UperCaseInputStream(InputStream in) &#123; super(in); &#125; @Override public int read() throws IOException &#123; int c=super.read(); return (c==-1?c:Character.toUpperCase((char)c)); &#125; @Override public int read(byte[] b, int off, int len) throws IOException &#123; int result=super.read(b,off,len); for(int i=off;i&lt;off+result;i++)&#123; b[i]=(byte)Character.toUpperCase((char)b[i]); &#125; return result; &#125;&#125; 测试IO装饰类1234567891011121314151617 public static void main(String[] args) throws IOException &#123;// Cake cake = new OilCake();// cake = new SaltDecorator(cake);// cake=new SugerDecorator(cake);// System.out.println(cake.getMessage());// System.out.println(cake.getCost()); int c; try &#123; InputStream in=new UperCaseInputStream(new BufferedInputStream(new FileInputStream("E:\\test.txt"))); while ((c=in.read())&gt;0) System.out.println((char)(c)); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;![Uploading image_647020.png . . .] 3. 总结（conclution) &emsp;&emsp;从上述我们可以看出来 ，装饰者模式用于已经存在的类添加额外的功能，但是它也有缺点，就是它要在设计中加入大量的小类，会造成额外的空间占用。其核心思想还是如下： &emsp;&emsp;多用组合，少用继承。针对接口编程，不针对实现编程。对拓展开放，对修改关闭。github地址：github.com/maskwang520]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot用WebSocket构建交互式的web应用]]></title>
    <url>%2F2017%2F10%2F12%2FSpringboot%E7%94%A8WebSocket%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84web%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebSocket是html5带来的一项重大的特性，使得浏览器与服务端之间真正长连接交互成为了可能，这篇文章会带领大家窥探一下Spring 对WebSocket的支持及使用。 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭HTTP协议的长连接和短连接，这两种实质上是TCP协议的长连接和短连接。 项目结构 12345678910111213└── src └── main └── java └── hello └── config └── WebsocketConfig.java └── controller └── GreetingController.java └── message └── Greeting.java └── HelloMessage.java └──test └── pom.xml 1.Maven引入Jar包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;sprigboot-websocket&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.编写客户端发送的消息和服务端回复的消息Java类1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class HelloMessage &#123; String name; public HelloMessage() &#123; &#125; public HelloMessage(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 1234567891011121314151617181920212223package hello.messaage;/** * Created by maskwang on 2017/10/12 0012. */public class Greeting &#123; String content; public Greeting() &#123; &#125; public Greeting(String content) &#123; this.content = content; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 注意在上面要有默认的构造器，没有的话，则会出现下面问题 这是因为序列化后，如果没有默认的构造器，则会让Springboot的默认序列化Jackson不能构造成原来的对象，反序列化还是需要通过默认的构造器来实现的 。客户端发送HelloMessage,服务端服务以Greeting。 ####3.Websocket配置类12345678910111213141516171819202122232425262728package hello.config;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;/** * Created by maskwang on 2017/10/12 0012. */@Configuration@EnableWebSocketMessageBrokerpublic class WebsocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123; @Override public void configureMessageBroker(MessageBrokerRegistry config) &#123; //客户端接收服务端消息的地址的前缀信息（客户端接受） config.enableSimpleBroker("/topic"); //客户端给服务端发消息的地址的前缀（客户端发送） config.setApplicationDestinationPrefixes("/app"); &#125; //这个方法的作用是添加一个服务端点，来接收客户端的连接。并开启SockJS的支持。 @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint("/socket").withSockJS(); &#125;&#125; registry.addEndpoint(“/socket”)表示添加了一个/socket端点，客户端和服务端就可以通过这个端点来进行连接。 withSockJS()的作用是开启SockJS支持 @EnableWebSocketMessageBroker别忘了。 configureMessageBroker(MessageBrokerRegistry config)定义消息代理，也就是服务端和客户端他们之间交换消息的规范。config.enableSimpleBroker(“/topic”);表明客户端接受服务端的消息时候，服务端的请求地址前缀。config.setApplicationDestinationPrefixes(“/app”)表明服务端接受客户端时候，客户端的请求地址前缀。4. 编写业务代码12345678910111213141516171819202122package hello.controller;import hello.messaage.Greeting;import hello.messaage.HelloMessage;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.stereotype.Controller;/** * Created by maskwang on 2017/10/12 0012. */@Controllerpublic class GreetingController &#123; @MessageMapping("/hello") //转发给服务端 @SendTo("/topic/greetings") public Greeting greeting(HelloMessage message) throws Exception &#123; Thread.sleep(1000); // simulated delay return new Greeting("Hello, " + message.getName() + "!"); &#125;&#125; @SendTo(“/topic/greetings”)是客户端发起连接后，订阅服务端消息时指定的一个地址，用于接收服务端的返回，也就是服务端返回的消息在客户端在订阅这个地址的消息后，客户端可以收到。定义怎样的客户端。 @MessageMapping(“/hello”)定义这个地址客户端发送的消息就会被映射这样的服务端。也就是客户端寻找那个服务端。定义了什么样的服务端。 理解上面两点很重要，后面都与这有关。 5. 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello WebSocket&lt;/title&gt; &lt;link href="/webjars/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;link href="/main.css" rel="stylesheet"&gt; &lt;script src="/webjars/jquery/3.1.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/sockjs-client/1.0.2/sockjs.min.js"&gt;&lt;/script&gt; &lt;script src="/webjars/stomp-websocket/2.3.3/stomp.min.js"&gt;&lt;/script&gt; &lt;script src="/app.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;h2 style="color: #ff0000"&gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being enabled. Please enable Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;&lt;div id="main-content" class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="connect"&gt;WebSocket connection:&lt;/label&gt; &lt;button id="connect" class="btn btn-default" type="submit"&gt;Connect&lt;/button&gt; &lt;button id="disconnect" class="btn btn-default" type="submit" disabled="disabled"&gt;Disconnect &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="col-md-6"&gt; &lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="name"&gt;What is your name?&lt;/label&gt; &lt;input type="text" id="name" class="form-control" placeholder="Your name here..."&gt; &lt;/div&gt; &lt;button id="send" class="btn btn-default" type="submit"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;table id="conversation" class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Greetings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="greetings"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var stompClient = null;function setConnected(connected) &#123; $("#connect").prop("disabled", connected); $("#disconnect").prop("disabled", !connected); if (connected) &#123; $("#conversation").show(); &#125; else &#123; $("#conversation").hide(); &#125; $("#greetings").html("");&#125;function connect() &#123; var socket = new SockJS('/socket'); //链接socket stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content); &#125;); &#125;);&#125;function disconnect() &#123; if (stompClient !== null) &#123; stompClient.disconnect(); &#125; setConnected(false); console.log("Disconnected");&#125;function sendName() &#123; stompClient.send("/app/hello", &#123;&#125;, JSON.stringify(&#123;'name': $("#name").val()&#125;));&#125;function showGreeting(message) &#123; $("#greetings").append("&lt;tr&gt;&lt;td&gt;" + message + "&lt;/td&gt;&lt;/tr&gt;");&#125;$(function () &#123; $("form").on('submit', function (e) &#123; e.preventDefault(); &#125;); $( "#connect" ).click(function() &#123; connect(); &#125;); $( "#disconnect" ).click(function() &#123; disconnect(); &#125;); $( "#send" ).click(function() &#123; sendName(); &#125;);&#125;); 前端我们需要用到两个js文件：sockjs.js和stomp.js SockJS：SockJS 是一个浏览器上运行的 JavaScript 库，如果浏览器不支持 WebSocket，该库可以模拟对 WebSocket 的支持，实现浏览器和 Web 服务器之间低延迟、全双工、跨域的通讯通道。StompStomp 提供了客户端和代理之间进行广泛消息传输的框架。Stomp 是一个非常简单而且易用的通讯协议实现，尽管代理端的编写可能非常复杂，但是编写一个 Stomp 客户端却是很简单的事情，另外你可以使用 Telnet 来与你的 Stomp 代理进行交互。 开启Socket var socket = new SockJS(‘/socket’); 先构建一个SockJS对象 stompClient = Stomp.over(socket); 用Stomp将SockJS进行协议封装 stompClient.connect()与服务端进行连接，同时有一个回调函数，处理连接成功后的操作信息。发送消息 stompClient.send(“/app/hello”, {}, JSON.stringify({‘name’: $(“#name”).val()}));是客户端向服务端发送消息 stompClient.subscribe(‘/topic/greetings’, function (greeting) { showGreeting(JSON.parse(greeting.body).content); }); //是服务端向客户端发送消息 点击connect后，发动任何message,服务端都会延迟一秒后，回复hello,message! 参考文献 HTTP长连接和短连接 Spring官方websocket例子 Spring WebSocket初探1 (Spring WebSocket入门教程)]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>springboot</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弄懂Fail-Safe,Fail-First]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%BC%84%E6%87%82Fail-Safe-Fail-First%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天在做算法题的时候，碰到的如下问题，记录下来加深记忆。很多时候我们都有这样一个需求，在迭代的时候（满足某个给定的条件）添加或者删除元素。结果却是等来了java.util.ConcurrentModificationException这个异常，追踪其原因，就是有些容器是Fail-Safe，Fail-First的12345678910111213public class CollectionTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (int a : arrayList) &#123; if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125;&#125; 1. Fail-Safe,Fail-First概念。 在ArrayList的里面有个内部类Itr。当我们获取到迭代器的时候，就会对这个类进行初始化，来看下这个类的源码，分析初始化做了些什么。123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 在初始化的时候，它会让expectedModCount = modCount，modCount在AbstractList，每次对ArrayList的结构性改变（remove,add）都会使得modCount相应的减1或者加1。来分析下我们刚开始出现问题的代码。当我们获取到迭代器的时候，此时expectedModCount = modCount。当remove的时候，modCount会加1，但是expectedModCount却不变，当执行Itr的next()操作时候，会执行上述源码中的checkForComodification()来检查expectedModCount = modCount，若不相等，则会throw ConcurrentModificationException。所以就不难分析出上述问题。 FailFirst:当我们在迭代获取集合元素的时候，在迭代器创建之后，对集合做一些结构性的改变（remove,add操作)，那么FailFirst容器首先会抛出 ConcurrentModificationException。 2. 如何解决上述问题。12345678910111213public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); ArrayList sub=new ArrayList(); for(int a:arrayList)&#123; if(a==1) sub.add(a); &#125; arrayList.removeAll(sub); System.out.println(arrayList); &#125; 上述这个办法好，但是却占额外空间。1234567891011121314public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) iterator.remove(); &#125; System.out.println(arrayList); &#125; 这样就不占额外的空间，是更好的办法。 iterator.remove()为啥不会抛异常，看看源码1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; expectedModCount = modCount;这句起作用，它删除元素后它会强制满足条件。所以不会抛异常。 3. Fail-Safe的出场 。 将刚开始的代码换成如下的形式,问题迎刃而解。1234567891011121314public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;Integer&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; int a = iterator.next(); if (a == 1) arrayList.remove(a); &#125; System.out.println(arrayList); &#125; 像CopyOnWriteArrayList这类容器就属于Fail-Safe容器。当集合结构改变的时候不会抛出异常，这是因为他们只是原始集合的复制，它用snapshot这个数组来保存集合。所以你原始集合的修改只会让原来的引用指向新的数组，而旧的引用还是被迭代器的snapshot所引用。因而他们属于Fail-Safe容器。看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; private boolean remove(Object o, Object[] snapshot, int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 从上面可以看出每次添加元素都是线程安全的，因为加了锁。另外，每添加一个元素，都会把原来的引用指向一个新的数组。所以对他进行操作没问题。所以使用Fail-Safe容器也是一种很好的解决办法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式2---观察者模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在我们的开发工作中，经常会遇到这样的问题。例如：对于A，对象B，C在原来引用了A。现在对象A的属性发生了变化，我们的需求是B，C能够同时感应到这种变化。且新增的对象D，也要引用A对象，那如何在不改变原来代码的基础上，如何做到呢。此时，观察者模式就能够很好的解决这个问题。 1. 为何需要观察者模式（why) Defidition:观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 下面通过一个和实例逐步弄清楚什么是观察者模式。 2. 如何实现观察者模式（通过实例来讲解how） 某气象站有这样一个应用：它实时检测当地温度，适度，压强。并让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都能实时更新相应的数据。气象站提供的数据结构如下。123456public class WeatherData &#123; float temp; float humidity; float pressture;//省略get,set方法&#125; 我们想到的办法就是让第一号布告板，第二号布告板，第三号布告板或者其他第三方接入Api都成为气象站的观察者，他们只需要在气象站注册，当气象站的数据发生变化的时候，会遍历每个观察者，调用update（）实现更新操作。step1:定义抽象接口1234567891011121314151617181920public interface Subject &#123; //主题，即气象站的抽象接口 //注册观察者 public void registerObserver(Observer o); //取消观察者 public void removeObserver(Observer o); //通知观察者执行更新操作 public void notifyObservers();&#125;public interface Observer &#123; //更新操作，等待Subject调用就实现了通知 public void update(float temp,float humidy,float pressure);&#125;public interface DisplayElement &#123; //对更新进行展示 public void display();&#125; 上述是接口，便于代码重用和面向接口编程，而不是面向实现编程。step2:实现具体的类123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressture; public WeatherData()&#123; observers=new ArrayList(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i=observers.indexOf(o); if(i&gt;=0) observers.remove(i); &#125; @Override public void notifyObservers() &#123; observers.stream().forEach((observer)-&gt;observer.update(temperature,humidity,pressture)); &#125; public void measurementsChanged()&#123;//通知 notifyObservers(); &#125; //属性改变了 public void setMeasurements(float temperature,float humidity,float pressture)&#123; this.temperature=temperature; this.humidity=humidity; this.pressture=pressture; measurementsChanged(); &#125;&#125; step3:Observer这里只提供一种实现，剩下的可以同样生成。123456789101112131415161718192021222324252627282930** * Created by maskwang on 2017/10/5 0005. * 时间原因这里只提供一种实现 */public class CurrentConditionsDisplay implements Observer,DisplayElement &#123; //这个观察者只在乎以下两个属性 private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this);//注册 &#125; @Override public void display() &#123; System.out.println(temperature+"**"+humidity); &#125; @Override public void update(float temp, float humidy, float pressure) &#123; this.humidity=humidy; this.temperature=temp; display(); &#125;&#125; step4:测试类12345678910111213public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); //订阅那个Object CurrentConditionsDisplay currentConditionsDisplay=new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(80,65,30.2f); weatherData.setMeasurements(82,70,28.4f); weatherData.setMeasurements(83,72,27.5f); &#125;&#125; Uml类图如下： 结果如下： 可以看到每次Subject变化，Observer跟着变化。 3. 观察者模式总结（conclusion） 以上实例可以看出来，观察者模式实现了Obseerver和Subject的解耦，Subject可以增删任意Observer,而Observer可以订阅任意的Subject。很好的满足了这种需求。这让我activemq，它其中就有一种发布订阅模式，在这里面生产者产生的消息，都能理解被消费者立即订阅到。可以看的出来这种思想应用的还是很广的。附上对应的github地址： https://github.com/maskwang520/designpattern.git]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式1-策略模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 1. 为什么需要策略模式 考虑到如下一个场景，你构造一个Duck的SuperClass,以后各种各样的鸭子都继承该SuperClass ,代码实现应该如下。12345678910111213public class Duck &#123; public void quack()&#123; //会叫 System.out.println("I can quack"); &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 具体的实现类如下123456789101112public class GreeHeadDuck extends Duck &#123; //绿头鸭 @Override public void play()&#123; System.out.println("I am green duck"); &#125;&#125;public class RedHeadDuck extends Duck&#123; //红头鸭 @Override public void play()&#123; System.out.println("I am red duck"); &#125;&#125; 上面这样看起来也没毛病啊，但是它有个问题就是，当给SuperClass加上fly()方法后，表示每个子类都会飞。即便是我后来的子类不能飞，它也可以fly。此时，我们可能会想到，覆盖fly()方法，方法里面什么都不做。但是问题还是很突出。原因如下： 代码在多个子类中重复。不管是什么类型的鸭子，都会继承来SuperClass的所有属性和方法，这其中有些子类根本就不具备。 运行时的行为不容易改变。我想让某个鸭子换个叫声，在不动SuperClass的情况下做不到。 很难知道所有鸭子共同的行为。比如fly方法，有些鸭子不具备，但是还是在父类中。 改一发动全身，我上面还是只添加fly(),有些鸭子不会飞，但是要覆盖方法。 我们接着可能会采用如下的解决办法，把fly,display从超类中抽出来，放进一个Flayable接口中。把quack()抽出来，放进Quackable接口中，代码如下。123456public interface Quackable &#123; //会叫的接口 public void quack();&#125;public interface Flyable &#123; //会飞接口 public void fly();&#125; 这样对于多个会飞Duck子类，每个子类都有一个实现Flyable()的类，在里面覆写fly()方法，会造成太多Flyable()的子类，无法复用。其次，还不能动态改变fly行为，因为已经写死啦。此时，设计原则就出来了，即：找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混到一起。 2. 如何使用策略模式 解决上述问题的根本是分开变化和不会变化的部分。Duck类中的fly(),quack()会随着鸭子的不同而改变，那我们将它们从Duck类中取出来，建立一组新类来代表每个行为。此时，设计原则就应用上了即，针对接口编程，而不是针对实现编程 这句话的理解在这里就是针对超类编程。前面我们设计 Quackable，Flyable，然后让具体的类去实现这两个接口，这样，就是针对实现编程，不利于动态修改和以后的拓展。因此，我们编写两个FlyBehavior,QuackBehavior两个接口，以及他们的实现类，这样，我们把FlyBehavior和QuackBehavior作为超类的属性，这个具体的实现通过set方法通过set()传递进去，这样实现面向接口编程，可以动态改变，也可以复用代码。代码实现如下：行为接口123456public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125; 实现类12345678910111213141516171819202122232425public class FlyNoWay implements FlyBehavior &#123; //不能飞 @Override public void fly() &#123; System.out.println("I can FlyNoWay"); &#125;&#125;public class FlyWithWins implements FlyBehavior &#123; //用翅膀飞 @Override public void fly() &#123; System.out.println("i can fly with wins"); &#125;&#125;public class Quack implements QuackBehavior &#123; //一般的叫 @Override public void quack() &#123; System.out.println("quack"); &#125;&#125;public class Squack implements QuackBehavior &#123; //嘶叫 @Override public void quack() &#123; System.out.println("squack"); &#125;&#125; 把基本接口作为超类的属性成员，面向接口编程12345678910111213141516171819202122232425262728public class Duck &#123; private FlyBehavior flyBehavior; //代理类，组合模式 private QuackBehavior quackBehavior; public void fly()&#123; flyBehavior.fly(); &#125; public void quack()&#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 测试类如下123456789public class Main &#123; public static void main(String[] args) &#123; Duck duck=new Duck(); duck.setFlyBehavior(new FlyNoWay()); duck.fly(); duck.setFlyBehavior(new FlyWithWins()); duck.fly(); &#125;&#125; 结果如下图 总结：上述做法的好处，面对不同飞行类型，可以在不修改Duck的基础上实现，这就是策略模式，根据你传入进来的具体实现类，执行不同的行为，这里关键就是运用多态这一特点。其次，不同的实现类可以复用，以前针对每个子类都有实现类，现在同一类型的都可以采用同一个实现类。 3. 结论 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，简单来说，就是定义了基础接口封装在类属性里面，可以根据不同的实现类，动态的改变行为。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>