<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HeadFirst设计模式1-策略模式]]></title>
    <url>%2F2017%2F10%2F07%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[作者在看HeadFirst设计模式，把整个学习过程记录下来，方便以后回顾，也可以与大家交流，欢迎拍板。整个系列每篇文章围绕why,how,conclusion这三方面展开。 1. 为什么需要策略模式 考虑到如下一个场景，你构造一个Duck的SuperClass,以后各种各样的鸭子都继承该SuperClass ,代码实现应该如下。12345678910111213public class Duck &#123; public void quack()&#123; //会叫 System.out.println("I can quack"); &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 具体的实现类如下123456789101112public class GreeHeadDuck extends Duck &#123; //绿头鸭 @Override public void play()&#123; System.out.println("I am green duck"); &#125;&#125;public class RedHeadDuck extends Duck&#123; //红头鸭 @Override public void play()&#123; System.out.println("I am red duck"); &#125;&#125; 上面这样看起来也没毛病啊，但是它有个问题就是，当给SuperClass加上fly()方法后，表示每个子类都会飞。即便是我后来的子类不能飞，它也可以fly。此时，我们可能会想到，覆盖fly()方法，方法里面什么都不做。但是问题还是很突出。原因如下： 代码在多个子类中重复。不管是什么类型的鸭子，都会继承来SuperClass的所有属性和方法，这其中有些子类根本就不具备。 运行时的行为不容易改变。我想让某个鸭子换个叫声，在不动SuperClass的情况下做不到。 很难知道所有鸭子共同的行为。比如fly方法，有些鸭子不具备，但是还是在父类中。 改一发动全身，我上面还是只添加fly(),有些鸭子不会飞，但是要覆盖方法。 我们接着可能会采用如下的解决办法，把fly,display从超类中抽出来，放进一个Flayable接口中。把quack()抽出来，放进Quackable接口中，代码如下。123456public interface Quackable &#123; //会叫的接口 public void quack();&#125;public interface Flyable &#123; //会飞接口 public void fly();&#125; 这样对于多个会飞Duck子类，每个子类都有一个实现Flyable()的类，在里面覆写fly()方法，会造成太多Flyable()的子类，无法复用。其次，还不能动态改变fly行为，因为已经写死啦。此时，设计原则就出来了，即：找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混到一起。 2. 如何使用策略模式 解决上述问题的根本是分开变化和不会变化的部分。Duck类中的fly(),quack()会随着鸭子的不同而改变，那我们将它们从Duck类中取出来，建立一组新类来代表每个行为。此时，设计原则就应用上了即，针对接口编程，而不是针对实现编程 这句话的理解在这里就是针对超类编程。前面我们设计 Quackable，Flyable，然后让具体的类去实现这两个接口，这样，就是针对实现编程，不利于动态修改和以后的拓展。因此，我们编写两个FlyBehavior,QuackBehavior两个接口，以及他们的实现类，这样，我们把FlyBehavior和QuackBehavior作为超类的属性，这个具体的实现通过set方法通过set()传递进去，这样实现面向接口编程，可以动态改变，也可以复用代码。代码实现如下：行为接口123456public interface FlyBehavior &#123; public void fly();&#125;public interface QuackBehavior &#123; public void quack();&#125; 实现类12345678910111213141516171819202122232425public class FlyNoWay implements FlyBehavior &#123; //不能飞 @Override public void fly() &#123; System.out.println("I can FlyNoWay"); &#125;&#125;public class FlyWithWins implements FlyBehavior &#123; //用翅膀飞 @Override public void fly() &#123; System.out.println("i can fly with wins"); &#125;&#125;public class Quack implements QuackBehavior &#123; //一般的叫 @Override public void quack() &#123; System.out.println("quack"); &#125;&#125;public class Squack implements QuackBehavior &#123; //嘶叫 @Override public void quack() &#123; System.out.println("squack"); &#125;&#125; 把基本接口作为超类的属性成员，面向接口编程12345678910111213141516171819202122232425262728public class Duck &#123; private FlyBehavior flyBehavior; //代理类，组合模式 private QuackBehavior quackBehavior; public void fly()&#123; flyBehavior.fly(); &#125; public void quack()&#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125; public void swim()&#123; //会游泳 System.out.println("I can swim"); &#125; public void play()&#123; //外表 System.out.println("I am a special duck with good look"); &#125;&#125; 测试类如下123456789public class Main &#123; public static void main(String[] args) &#123; Duck duck=new Duck(); duck.setFlyBehavior(new FlyNoWay()); duck.fly(); duck.setFlyBehavior(new FlyWithWins()); duck.fly(); &#125;&#125; 结果如下图 总结：上述做法的好处，面对不同飞行类型，可以在不修改Duck的基础上实现，这就是策略模式，根据你传入进来的具体实现类，执行不同的行为，这里关键就是运用多态这一特点。其次，不同的实现类可以复用，以前针对每个子类都有实现类，现在同一类型的都可以采用同一个实现类。 3. 结论 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，简单来说，就是定义了基础接口封装在类属性里面，可以根据不同的实现类，动态的改变行为。]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>