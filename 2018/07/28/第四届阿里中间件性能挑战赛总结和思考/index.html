<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第四届阿里中间件性能挑战赛总结和思考 | Maskwang blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="随着复赛今天截止,为期两个月的挑战赛也终于结束了.这两个月里很大一部分时间花在这上面,有过欢乐,也有为分数刷不上去而发愁.作为第一次参加比赛,对比赛结果还算是满意吧.而在这个过程中,对多线程知识,netty,nio等知识的深入认识.">
<meta name="keywords" content="中间件比赛">
<meta property="og:type" content="article">
<meta property="og:title" content="第四届阿里中间件性能挑战赛总结和思考">
<meta property="og:url" content="http://yoursite.com/2018/07/28/第四届阿里中间件性能挑战赛总结和思考/index.html">
<meta property="og:site_name" content="Maskwang blogs">
<meta property="og:description" content="随着复赛今天截止,为期两个月的挑战赛也终于结束了.这两个月里很大一部分时间花在这上面,有过欢乐,也有为分数刷不上去而发愁.作为第一次参加比赛,对比赛结果还算是满意吧.而在这个过程中,对多线程知识,netty,nio等知识的深入认识.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-84512faf33c17a59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-863761875aebfaa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-f6b36d6a20b612d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-4c032cd424bcac24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-83c1f99241e49a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-ebcd957e8b1139be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5281821-2f3e5ddc8e1ce661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-07-28T15:01:10.133Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第四届阿里中间件性能挑战赛总结和思考">
<meta name="twitter:description" content="随着复赛今天截止,为期两个月的挑战赛也终于结束了.这两个月里很大一部分时间花在这上面,有过欢乐,也有为分数刷不上去而发愁.作为第一次参加比赛,对比赛结果还算是满意吧.而在这个过程中,对多线程知识,netty,nio等知识的深入认识.">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5281821-84512faf33c17a59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Maskwang blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Maskwang blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Talk is nothing,Show me the code</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-第四届阿里中间件性能挑战赛总结和思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/28/第四届阿里中间件性能挑战赛总结和思考/" class="article-date">
  <time datetime="2018-07-28T14:59:04.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/中间件比赛/">中间件比赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      第四届阿里中间件性能挑战赛总结和思考
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着复赛今天截止,为期两个月的挑战赛也终于结束了.这两个月里很大一部分时间花在这上面,有过欢乐,也有为分数刷不上去而发愁.作为第一次参加比赛,对比赛结果还算是满意吧.而在这个过程中,对多线程知识,netty,nio等知识的深入认识.<br><a id="more"></a><br>下面是对比赛的总结和思考.排名如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5281821-84512faf33c17a59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="初赛：《Service-Mesh-Agent-for-Apache-Dubbo-Incubating-》"><a href="#初赛：《Service-Mesh-Agent-for-Apache-Dubbo-Incubating-》" class="headerlink" title="初赛：《Service Mesh Agent for Apache Dubbo (Incubating) 》"></a>初赛：《Service Mesh Agent for Apache Dubbo (Incubating) 》</h5><ul>
<li>赛题的思考</li>
</ul>
<p>题目看起来是让我们实现一个rpc agent.因为官方已经给出了consumer和provider,选手就是要实现两个代理,第一个代理是consumer-agent,负责把consumer的调用通过自定义协议发动给Provider-agent.第二个代理就是provider-agent.他的任务就是接收Consumer-agent通过网络发动过来的消息,然后通过dubbo调用provider.最后把结果返回给consumer-agent.整个系统的调用图如下:<br><img src="https://upload-images.jianshu.io/upload_images/5281821-863761875aebfaa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>设计和实现.</li>
</ul>
<p>整个调用过程如下所示:<br><img src="https://upload-images.jianshu.io/upload_images/5281821-f6b36d6a20b612d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名文件.jpg"></p>
<ul>
<li>①处这里采用Netty Http应用作为服务端,处理Consumer发送过来的http请求.</li>
<li>②处这里就是在Consumer-agent开启Netty Client,Provider-agent端开启Netty Server进行请求和响应.</li>
<li>③ Provider-agent通Netty Client去调用Provider的服务.</li>
<li>④ Provider把结果返回给Consumer-agent.</li>
<li>⑤ Consumer-agent把结果封装成HttpResponse返回给客户端.</li>
</ul>
<p>Provider提供的服务如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 计算传入参数的哈希值.</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> str 随机字符串</div><div class="line">   * <span class="doctag">@return</span> 该字符串的哈希值</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个代码我放在github中,这里不对整个代码做分析,只分析出关键的点.</p>
<h6 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h6><p>如下图,3个provider的负载能力如下,那么我们可以选择负载均衡算法的时候,把这个考虑进去.我选择是随机加权算法.根据大家的一致认同,small:meddium:large = 1:2:2.<br><img src="https://upload-images.jianshu.io/upload_images/5281821-4c032cd424bcac24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Selection_020.png"><br>所有的服务都运行在docker环境中,而用的etcd作为服务发现的组件.事先并不知道那台机器是small,large,meddium.那么我们可以考虑把参数加上启动参数.一旦服务启动,这些信息,都会注册到etcd中.然后取出来,做相应的判断就行.<br><img src="https://upload-images.jianshu.io/upload_images/5281821-83c1f99241e49a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Selection_021.png"></p>
<p>在etcd做服务发现的时候,把型号信息转换成比例注册上去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//small 1; meddium和large是2.</span></div><div class="line"><span class="keyword">if</span>(val.equals(<span class="string">"small"</span>)) &#123;</div><div class="line">                endpoints.add(<span class="keyword">new</span> Endpoint(host, port, <span class="number">1</span>));</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                endpoints.add(<span class="keyword">new</span> Endpoint(host, port, <span class="number">2</span>));</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>Consumer在选择那个Provider的时候就可以根据以上的信息,轮询选择一个.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//向endpoints加入5个实例,small一个,meddium和large都是2个.</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == endpoints) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (ConsumerAgentHttpServerHandler.class) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == endpoints) &#123;</div><div class="line">                    endpoints = RegistryInstance.getInstance().find(<span class="string">"com.alibaba.dubbo.performance.demo.provider.IHelloService"</span>);</div><div class="line">                    ListIterator&lt;Endpoint&gt; it = endpoints.listIterator();</div><div class="line">                    <span class="keyword">while</span> (it.hasNext())&#123;</div><div class="line">                        Endpoint temp = it.next();</div><div class="line">                        <span class="keyword">if</span>(temp.getSize()==<span class="number">2</span>) &#123;</div><div class="line">                            it.add(temp);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> id = count.getAndIncrement();</div><div class="line">        <span class="keyword">if</span>(id&gt;=<span class="number">4</span>)&#123;</div><div class="line">            count.set(<span class="number">0</span>);</div><div class="line">            id=<span class="number">4</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 简单的负载均衡，随机取一个</span></div><div class="line">        Endpoint endpoint = endpoints.get(id);</div></pre></td></tr></table></figure></p>
<p>这样一个随机加权的算法就实现了.</p>
<h6 id="EventLoop复用"><a href="#EventLoop复用" class="headerlink" title="EventLoop复用"></a>EventLoop复用</h6><p>当我们创建Provident-agent的时候,我们是否可以考虑Eventloop的复用,这样每个请求从接收到发动都是用同一个线程处理的,没有上下文切换.另外一个,这样做好处,把channel和Eventloop绑定起来,也就限定了channel的个数,相当于做了一个channel的缓存(因为channel的数量得控制).一举两得.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">providerServerStart</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>);</div><div class="line">        putMap(workerGroup);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerBootstrap sbs = <span class="keyword">new</span> ServerBootstrap().group(bossGroup, workerGroup)</div><div class="line">                    .channel(NioServerSocketChannel.class)</div><div class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</div><div class="line">                    .childHandler(<span class="keyword">new</span> ProviderAgentHttpServerChannelInitializer());</div><div class="line">            LOGGER.info(<span class="string">"provider netty server start"</span>);</div><div class="line">            ChannelFuture future = sbs.bind(port).sync();</div><div class="line">            future.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="comment">//预先把channel设置好,复用上面的eventloop.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMap</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (EventExecutor executor : group) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                map.put((EventLoop) executor, connecManager.getChannel( (EventLoop) executor));</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h6 id="回调的设计"><a href="#回调的设计" class="headerlink" title="回调的设计"></a>回调的设计</h6><p>当Provider返回给结果后,那我们应该如何把结果返回给Consumer-agent呢,也就是它如何记住之前的通道.这里采用的是一个回调的设计.这样就能够记住上下文,也就是记住过来时候的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">```java</div><div class="line"> @Override</div><div class="line">    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception &#123;</div><div class="line">        Map&lt;String, String&gt; data = HttpParser.parse(msg);</div><div class="line">        handle(new RequestWrapper(data.get(&quot;interface&quot;),</div><div class="line">                data.get(&quot;method&quot;),</div><div class="line">                data.get(&quot;parameterTypesString&quot;),</div><div class="line">                data.get(&quot;parameter&quot;)), (result) -&gt; &#123;</div><div class="line">            FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(result.getBytes()));</div><div class="line">            response.headers().set(CONTENT_TYPE, &quot;text/plain&quot;);</div><div class="line">            response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());</div><div class="line">            ctx.write(response);</div><div class="line">            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);</div><div class="line">        &#125;,ctx.channel().eventLoop());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当结果返回后,通过回调调用回调函数的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//拿到结果后,回调</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(RpcResponse response)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.response = response;</div><div class="line">        sender.accept(<span class="keyword">new</span> String(response.getBytes()).trim());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>反思和思考<h6 id="可以批量flush-批量decode-来源于朋友徐靖峰的思想"><a href="#可以批量flush-批量decode-来源于朋友徐靖峰的思想" class="headerlink" title="可以批量flush,批量decode(来源于朋友徐靖峰的思想)"></a>可以批量flush,批量decode(来源于朋友徐靖峰的思想)</h6><img src="https://upload-images.jianshu.io/upload_images/5281821-ebcd957e8b1139be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>Netty 提供了一个方便的解码工具类 ByteToMessageDecoder ，如图上半部分所示，这个类具备 accumulate 批量解包能力，可以尽可能的从 socket 里读取字节，然后同步调用 decode 方法，解码出业务对象，并组成一个 List 。最后再循环遍历该 List ，依次提交到 ChannelPipeline 进行处理。此处我们做了一个细小的改动，如图下半部分所示，即将提交的内容从单个 command ，改为整个 List 一起提交，如此能减少 pipeline 的执行次数，同时提升吞吐量。这个模式在低并发场景，并没有什么优势，而在高并发场景下对提升吞吐量有不小的性能提升。</p>
<h6 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h6><p>上面我的做法有点硬编码的意思,而且随机的话,而且不确定性有点大.那是是否可以考虑根据调用的次数来做负载均衡,也就是说,给句每个Provider请求的次数,尽量把请求分给请求量少的Provider,当然这个量还是得加权.实现的复杂性有点高.</p>
<h6 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h6><p>经过朋友提醒,是否可以尝试下,限流,也就是说不放那么多请求进取,只通过一部分来请求,待完成之后,再放另外一部分,这个可以尝试用令牌桶来实现.处于理论阶段,没实际尝试过.</p>
<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><p>我做的处理里面都是采用的jdk自带的编码方式.如果采用kryo,protobuf的方式,性能上也会有一定的提升.</p>
<p>我的代码:<a href="https://github.com/maskwang520/springforall.git" target="_blank" rel="external">https://github.com/maskwang520/springforall.git</a></p>
<hr>
<h5 id="复赛：实现一个进程内的队列引擎，单机可支持100万队列以上-能够承受2亿消息的存取"><a href="#复赛：实现一个进程内的队列引擎，单机可支持100万队列以上-能够承受2亿消息的存取" class="headerlink" title="复赛：实现一个进程内的队列引擎，单机可支持100万队列以上,能够承受2亿消息的存取."></a>复赛：实现一个进程内的队列引擎，单机可支持100万队列以上,能够承受2亿消息的存取.</h5><ul>
<li>赛题的思考<br>题目要求有5个:<br>1.各个阶段线程数在20~30左右<br>2.发送阶段：消息大小在50字节左右，消息条数在20亿条左右，也即发送总数据在100G左右<br>3.索引校验阶段：会对所有队列的索引进行随机校验；平均每个队列会校验1~2次；<br>4.顺序消费阶段：挑选20%的队列进行全部读取和校验；<br>5.发送阶段最大耗时不能超过1800s；索引校验阶段和顺序消费阶段加在一起，最大耗时也不能超过1800s；超时会被判断为评测失败。</li>
</ul>
<p><strong>100万个queue,20亿消息,如果放内存是完全不现实的,内存肯定会爆.接下来自然想到把消息存放到文件中,内存中只放索引就行.但是内存存放索引,是20亿消息的消息,索引自然是由(消息起始位置+长度)构成.但是这样的Map<queue,index>存放的索引有20亿,疯狂的FullGc是不可避免的,Full Gc一多,Tps自然上不去.后来想到,消息按块存储(多个消息存在一个块中),索引的时候按块索引.这样就能把Map里面存的只有100万(queue的个数),示意图如下:</queue,index></strong><br><img src="https://upload-images.jianshu.io/upload_images/5281821-2f3e5ddc8e1ce661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名文件.png"></p>
<h6 id="Block的设计"><a href="#Block的设计" class="headerlink" title="Block的设计"></a>Block的设计</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</div><div class="line">    <span class="comment">//开始位置</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> startPosition;</div><div class="line"></div><div class="line">    <span class="comment">//长度</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length;</div><div class="line">    <span class="comment">//Block中已经存放的消息的条数</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Block</span><span class="params">(Long startPosition, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.startPosition = startPosition;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>因为一个queue中可能有多个Block,在消息检索的时候给出的是在队列中的偏移量,那么size这个域方便后面消息检索的时候判断在哪个block中.</p>
</li>
<li><p>消息缓存的设计<br>因为每当来一个消息都要flush到文件中去,这样Io的时间就太多了,题目的关键点在于如何减少Io的时间.所以可以采用消息的缓存来处理.每当来一个消息,就放入缓存中,当缓存中超过10次消息的时候,就同步写入到文件中去.这样的话,相当于每10次写,才做一次Io.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataCache</span> </span>&#123;</div><div class="line">   <span class="comment">//消息缓存</span></div><div class="line">    <span class="keyword">public</span> ByteBuffer dataBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里将缓存的大小设置为1024Byte,当然你也可以设置成更大.这里有个小Tips.<strong>缓存的消息最好设置成Block的大小.这样当缓存满了之后,就可以直接写入到一个Block块中,而不用接着上一个Block写(上面一个Block写),这样设计,写入更简单,每次flush到文件的时候,只要新开辟一个新的Block,而不用管之前的Block.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以块为索引,一个队列可能有多个块,且块的写入有顺序,所有用List来存Block.</span></div><div class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Block&gt;&gt; blockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"><span class="keyword">public</span> Map&lt;String, DataCache&gt; cacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h6 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h6><p>因为不可能每个队列的消息都用一个文件来存放,所以这里用hash来把文件限定在32个.一个queue的Block必须在一个文件里面.不同queue的Block可以在一个文件里面.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据队列的名字hash到对应的文件中,共32个文件</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">hashFile</span><span class="params">(String queueName)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> queueName.hashCode() &amp; <span class="number">0x1f</span>;</div><div class="line">       <span class="comment">//return 0;</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>还存在一个问题就是,往一个文件中写入消息的时候,什么位置写,因为按块写.所以已经写过的块不能用.只能从新开辟一个块,块与块之间尽可能紧凑.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//block的大小为1024,根据当前文件已经存在的写的位置,找到下一个比该位置大的,且是1024的倍数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLeastBlockPosition</span><span class="params">(<span class="keyword">long</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> initSize = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (i * initSize &lt;= length) &#123;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//定义到可用的块的第一个位置</span></div><div class="line">    <span class="keyword">return</span> i * initSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="消息存放"><a href="#消息存放" class="headerlink" title="消息存放"></a>消息存放</h6><p>这里采用的是原生的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">```java</div><div class="line">public void put(String queueName, byte[] message) &#123;</div><div class="line">        int hash = hashFile(queueName);</div><div class="line">        String path = DIRPATH + hash + &quot;.txt&quot;;</div><div class="line">        lock.lock();</div><div class="line">        //创建文件</div><div class="line">        File file = new File(path);</div><div class="line">        if (!file.exists()) &#123;</div><div class="line">            try &#123;</div><div class="line">                file.createNewFile();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!blockMap.containsKey(queueName)) &#123;</div><div class="line">            List&lt;Block&gt; list = new ArrayList();</div><div class="line">            blockMap.put(queueName, list);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!cacheMap.containsKey(queueName)) &#123;</div><div class="line">            DataCache dataCache = new DataCache();</div><div class="line">            cacheMap.put(queueName, dataCache);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        DataCache dataCache = cacheMap.get(queueName);</div><div class="line">      //每10次flush到文件中</div><div class="line">        if (dataCache.count == 10) &#123;</div><div class="line">            FileChannel fileChannel = null;</div><div class="line">            // long fileLength = 0;</div><div class="line">            try &#123;</div><div class="line">                fileChannel = new RandomAccessFile(file, &quot;rw&quot;).getChannel();</div><div class="line">                //fileLength = raf.length();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            long blockPosition;</div><div class="line">            try &#123;</div><div class="line">                blockPosition = getLeastBlockPosition(getLeastBlockPosition(fileChannel.size()));</div><div class="line">                Block block = new Block(blockPosition, dataCache.dataBuffer.position());</div><div class="line">                block.size = 10;</div><div class="line">                blockMap.get(queueName).add(block);</div><div class="line">                dataCache.dataBuffer.flip();</div><div class="line">                fileChannel.position(blockPosition);</div><div class="line">                fileChannel.write(dataCache.dataBuffer);</div><div class="line">                dataCache.dataBuffer.clear();</div><div class="line"></div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;finally &#123;</div><div class="line">                try &#123;</div><div class="line">                    fileChannel.close();</div><div class="line">                &#125;catch (Exception e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            //放入缓存中</div><div class="line">            dataCache.dataBuffer.putInt(message.length);</div><div class="line">            dataCache.dataBuffer.put(message);</div><div class="line">            dataCache.count++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        lock.unlock();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h6 id="消息获取"><a href="#消息获取" class="headerlink" title="消息获取"></a>消息获取</h6><p>消息获取的思路是根据队列名,找到该队列对应的List<block>,然后根据偏移量,找到属于哪个block.找到具体的Block后,然后遍历Block,找到偏移量的开始位置,取相应数量的消息即可.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Collection&lt;<span class="keyword">byte</span>[]&gt; get(String queueName, <span class="keyword">long</span> offset, <span class="keyword">long</span> num) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//队列不存在</span></div><div class="line">        <span class="keyword">if</span> (!blockMap.containsKey(queueName)) &#123;</div><div class="line">            <span class="keyword">return</span> EMPTY;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//消息集合</span></div><div class="line">        List&lt;<span class="keyword">byte</span>[]&gt; msgs = <span class="keyword">new</span> ArrayList();</div><div class="line">        List&lt;Block&gt; blocks = blockMap.get(queueName);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> hash = hashFile(queueName);</div><div class="line">        String path = DIRPATH + hash + <span class="string">".txt"</span>;</div><div class="line">        FileChannel fileChannel = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> size = blocks.get(<span class="number">0</span>).size;</div><div class="line">        <span class="keyword">int</span> eleNum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//记录了目标block所在的下标</span></div><div class="line">        <span class="keyword">int</span> blockNum = <span class="number">0</span>;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(path), <span class="string">"rw"</span>).getChannel();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; blocks.size() &amp;&amp; size &lt; offset; i++, blockNum++) &#123;</div><div class="line">                size += blocks.get(i).size;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            size = size - blocks.get(blockNum).size;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = blockNum; i &lt; blocks.size(); i++) &#123;</div><div class="line">                <span class="comment">//size+=blocks.get(i).size;</span></div><div class="line">                <span class="comment">// size-=blocks.get(i).size;</span></div><div class="line">                <span class="keyword">int</span> length = blocks.get(i).length;</div><div class="line">                MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, blocks.get(i).startPosition, length);</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (sum &lt; length &amp;&amp; size &lt; offset) &#123;</div><div class="line">                    <span class="keyword">int</span> len = buffer.getInt();</div><div class="line">                    sum += <span class="number">4</span>;</div><div class="line">                    sum += len;</div><div class="line">                    buffer.position(sum);</div><div class="line">                    size++;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (size &gt;= offset) &#123;</div><div class="line">                    <span class="keyword">while</span> (buffer.position() &lt; length &amp;&amp; eleNum &lt;= num) &#123;</div><div class="line">                        <span class="keyword">int</span> len = buffer.getInt();</div><div class="line">                        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">                        buffer.get(temp, <span class="number">0</span>, len);</div><div class="line">                        eleNum++;</div><div class="line">                        msgs.add(temp);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (eleNum &gt; num) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                fileChannel.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            lock.unlock();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> msgs;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></block></p>
<h6 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h6><ul>
<li>将所有的ByteBuf池化,包括缓存的那部分ByteBuf.通过ThreadLocal,将ByteBuf与线程绑定起来,后面申请Buffer,直接从对应的线程里面去申请即可.</li>
<li>在写入的时候,可以不同步写,实现异步写.由一个线程去异步flush到文件里面</li>
<li>当读取消息块达到临界点的时候,由单线程申请buffer资源来预读后面的消息块存入,并缓存.<br>我的代码:<a href="https://github.com/maskwang520/messagequeue.git" target="_blank" rel="external">https://github.com/maskwang520/messagequeue.git</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/28/第四届阿里中间件性能挑战赛总结和思考/" data-id="cjmw6phh5002llgor4bnog3db" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/中间件比赛/">中间件比赛</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/07/28/Redis面试必备知识点/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Redis面试必备知识点</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPattern/">DesignPattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java源码分析/">Java源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Springboot/">Springboot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flink/">flink</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/netty/">netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件比赛/">中间件比赛</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie-Session/">Cookie&Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-2/">HTTP/2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambada表达式/">Lambada表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/">Springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/">flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中间件比赛/">中间件比赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/红黑树/">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cookie-Session/" style="font-size: 10px;">Cookie&Session</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTP-2/" style="font-size: 12.5px;">HTTP/2</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Java基础/" style="font-size: 12.5px;">Java基础</a> <a href="/tags/Lambada表达式/" style="font-size: 10px;">Lambada表达式</a> <a href="/tags/LeetCode/" style="font-size: 12.5px;">LeetCode</a> <a href="/tags/Netty/" style="font-size: 12.5px;">Netty</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Spring/" style="font-size: 12.5px;">Spring</a> <a href="/tags/Springboot/" style="font-size: 10px;">Springboot</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/netty/" style="font-size: 12.5px;">netty</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/中间件比赛/" style="font-size: 10px;">中间件比赛</a> <a href="/tags/红黑树/" style="font-size: 10px;">红黑树</a> <a href="/tags/设计模式/" style="font-size: 17.5px;">设计模式</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/28/第四届阿里中间件性能挑战赛总结和思考/">第四届阿里中间件性能挑战赛总结和思考</a>
          </li>
        
          <li>
            <a href="/2018/07/28/Redis面试必备知识点/">Redis面试必备知识点</a>
          </li>
        
          <li>
            <a href="/2018/05/27/Leetcode-Permutations-II/">Leetcode:Permutations II</a>
          </li>
        
          <li>
            <a href="/2018/05/27/LeetCode53-Maximum-Subarray/">LeetCode53. Maximum Subarray</a>
          </li>
        
          <li>
            <a href="/2018/05/13/Netty源码分析系列1-BootStrap的分析/">Netty源码分析系列1:BootStrap的分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Maskwang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>